# Теория по алгоритмам <!-- omit in $to$ c -->

## Содержание

- [Теория по алгоритмам ](#теория-по-алгоритмам-)
  - [Содержание](#содержание)
  - [1. Обходы графа](#1-обходы-графа)
    - [1.1. Ориентированный граф, псевдограф. Неориентированный граф, псевдограф. Связность в неориентированном графе, компоненты связности. Слабая и сильная связность в ориентированном графе. Компоненты слабой, сильной связности](#11-ориентированный-граф-псевдограф-неориентированный-граф-псевдограф-связность-в-неориентированном-графе-компоненты-связности-слабая-и-сильная-связность-в-ориентированном-графе-компоненты-слабой-сильной-связности)
      - [Ориентированный граф](#ориентированный-граф)
      - [Неориентированный граф](#неориентированный-граф)
    - [1.2. Обход в глубину. Цвета вершин. Времена входа и выхода. Лемма о белых путях (с доказательством)](#12-обход-в-глубину-цвета-вершин-времена-входа-и-выхода-лемма-о-белых-путях-с-доказательством)
      - [Обход в глубину](#обход-в-глубину)
      - [Лемма о белых путях](#лемма-о-белых-путях)
    - [1.3. Проверка связности неориентированного графа. Поиск цикла в неориентированном и ориентированном графе. Топологическая сортировка](#13-проверка-связности-неориентированного-графа-поиск-цикла-в-неориентированном-и-ориентированном-графе-топологическая-сортировка)
      - [Проверка связности неориентированного графа](#проверка-связности-неориентированного-графа)
      - [Поиск цикла в неориентированном и ориентированном графе](#поиск-цикла-в-неориентированном-и-ориентированном-графе)
      - [Топологическая сортировка](#топологическая-сортировка)
    - [1.4. Нахождение компонент сильной связности. Алгоритм Косарайю с доказательством корректности(концепция). Алгоритм Тарьяна без доказательства корректности](#14-нахождение-компонент-сильной-связности-алгоритм-косарайю-с-доказательством-корректностиконцепция-алгоритм-тарьяна-без-доказательства-корректности)
      - [Нахождение компонент сильной связности](#нахождение-компонент-сильной-связности)
      - [Алгоритм Косарайю с доказательством корректности(концепция)](#алгоритм-косарайю-с-доказательством-корректностиконцепция)
      - [Алгоритм Тарьяна без доказательства корректности](#алгоритм-тарьяна-без-доказательства-корректности)
    - [1.5. Компоненты реберной двусвязности. Мосты. Поиск мостов](#15-компоненты-реберной-двусвязности-мосты-поиск-мостов)
      - [Компоненты реберной двусвязности](#компоненты-реберной-двусвязности)
      - [Мосты](#мосты)
      - [Поиск мостов](#поиск-мостов)
    - [1.6. Компоненты вершинной двусвязности. Точки сочленения. Поиск точек сочленения](#16-компоненты-вершинной-двусвязности-точки-сочленения-поиск-точек-сочленения)
      - [Компоненты вершинной двусвязности](#компоненты-вершинной-двусвязности)
      - [Точки сочленения](#точки-сочленения)
      - [Поиск точек сочленения](#поиск-точек-сочленения)
    - [1.7. Волновой алгоритм. Обход в ширину (применение очереди в волновом алгоритме)](#17-волновой-алгоритм-обход-в-ширину-применение-очереди-в-волновом-алгоритме)
      - [Волновой алгоритм](#волновой-алгоритм)
      - [Обход в ширину (применение очереди в волновом алгоритме)](#обход-в-ширину-применение-очереди-в-волновом-алгоритме)
    - [1.8. Критерий существования Эйлерова пути и цикла в ориентированном и неориентированном графе. Поиск эйлерова пути и цикла](#18-критерий-существования-эйлерова-пути-и-цикла-в-ориентированном-и-неориентированном-графе-поиск-эйлерова-пути-и-цикла)
      - [Критерий существования Эйлерова пути и цикла в неориентированном графе](#критерий-существования-эйлерова-пути-и-цикла-в-неориентированном-графе)
      - [Критерий существования Эйлерова пути и цикла в ориентированном графе](#критерий-существования-эйлерова-пути-и-цикла-в-ориентированном-графе)
      - [Поиск эйлерова пути и цикла](#поиск-эйлерова-пути-и-цикла)

## 1. Обходы графа

### 1.1. Ориентированный граф, псевдограф. Неориентированный граф, псевдограф. Связность в неориентированном графе, компоненты связности. Слабая и сильная связность в ориентированном графе. Компоненты слабой, сильной связности

#### Ориентированный граф

> **Ориентированным графом** (англ. *directed graph*) $G$ называется пара $G = (V, E)$, где $V$ — множество вершин (англ. vertices), а $E \subset V \times V$ — множество рёбер.

> **Псевдограф(*мультиорграф*)** — это ориентированный граф, в котором разрешены кратные дуги, то есть дуги, имеющие те же начальные и конечные вершины.

**Псевдографом** $G$ называется упорядоченная пара $G := (V, A)$, в которой $V$ — множество вершин, $A$ — мультимножество упорядоченных пар вершин. Элементы этого множества называются дугами.

> Ориентированный граф называется **слабо связным**, если соответствующий неориентированный граф является связным;

> Ориентированный граф называется **сильно связным**, если всякая вершина $v$ достижима из любой другой вершины $v$;

> **Компонентой сильной связности** ориентированного графа называется максимальный по включению сильно связный подграф. Другими словами, это подграф, любые две вершины которого принадлежат какому-либо циклу, и содержащий все такие циклы для своих вершин.

> **Компонентой слабой связности** ориентированного графа называют его максимальный слабо связный подграф.

#### Неориентированный граф

> **Неориентированным графом** (англ. *undirected graph*) $G$ называется пара $G = (V, E)$, где $V$ — множество вершин, а $E \subset {{v,u} : v,u \in V}$ — множество рёбер.

Формально, псевдографом (*мультифграфом*) $G$ называется упорядоченная пара $G := (V, E)$, в которой $V$ — множество вершин, $E$ — мультимножество неупорядоченных пар вершин. Элементы этого множества называются рёбрами.

> Неориентированный граф называется *связным*, если все его вершины достижимы из некоторой вершины (эквивалентно, из любой его вершины).

> **Компонентой связности** неориентированного графа называется максимальный по включению связный подграф

### 1.2. Обход в глубину. Цвета вершин. Времена входа и выхода. Лемма о белых путях (с доказательством)

#### Обход в глубину

> **Обход в глубину** (поиск в глубину, англ. *Depth-First Search*, *DFS*) — один из основных методов обхода графа, часто используемый для проверки связности, поиска цикла и компонент сильной связности и для топологической сортировки.

```c++
#include <vector>

std::vector<std::vector<int>> graph; // граф
int vertex_count; // число вершин

std::vector<int> color; // цвет вершины (0, 1, или 2)

std::vector<int> time_in, time_out; // "времена" захода и выхода из вершины
int dfs_timer = 0; // "таймер" для определения времён

void dfs (int vertex) {
  time_in[vertex] = dfs_timer++;
  color[vertex] = 1;
  for (int u : graph[vertex])
    if (color[u] == 0)
      dfs(u);
  color[v] = 2;
  time_out[v] = dfs_timer++;
}
```

#### Лемма о белых путях

> Лемма: Не существует такого момента выполнения поиска в глубину, в который бы существовало ребро из черной вершины в белую.

**Доказательство**: Пусть в процессе выполнения процедуры DFS нашлось ребро из черной вершины  $v$ в белую вершину u. Рассмотрим момент времени, когда мы запустили DFS(v). В этот момент вершина  $v$ была перекрашена из белого в серый, а вершина u была белая. Далее в ходе выполнения алгоритма будет запущен DFS(u), поскольку обход в глубину обязан посетить все белые вершины, в которые есть ребро из v. По алгоритму вершина  $v$ будет покрашена в черный цвет тогда, когда завершится обход всех вершин, достижимых из нее по одному ребру, кроме тех, что были рассмотрены раньше нее. Таким образом, вершина  $v$ может стать черной только тогда, когда DFS выйдет из вершины u, и она будет покрашена в черный цвет. Получаем противоречие.

### 1.3. Проверка связности неориентированного графа. Поиск цикла в неориентированном и ориентированном графе. Топологическая сортировка

#### Проверка связности неориентированного графа

Небольшая модификация алгоритма обхода в глубину, в которой будем возвращать количество посещенных вершин. Запустим такой **DFS** от некоторой вершины графа $G$, если его результат равен $|V|$, то мы побывали во всех вершинах графа, а следовательно он связен, иначе какие-то вершины остались непосещенными. Работает алгоритм за $O(|V|+|E|)$

```c++
std::vector<std::vector<int>> graph; // граф

// visited — массив цветов вершин  
int dfs(int vertex, std::vector<bool> visited):              
  int visitedVertices = 1
  visited[vertex] = true // помечаем вершину как пройденную
  for (auto u : graph[vertex]) // проходим по смежным с u вершинам
    // проверяем, не находились ли мы ранее в выбранной вершине
    if (!visited[v])
      visitedVertices += dfs(v, visited)
    return visitedVertices
```

#### Поиск цикла в неориентированном и ориентированном графе

*Условие:*

Пусть дан ориентированный или неориентированный граф без петель и кратных рёбер. Требуется проверить, является ли он ациклическим, а если не является, то найти любой цикл.

*Решение:*

Произведём серию поисков в глубину в графе. Т.е. из каждой вершины, в которую мы ещё ни разу не приходили, запустим поиск в глубину, который при входе в вершину будет красить её в серый цвет, а при выходе - в чёрный. И если поиск в глубину пытается пойти в серую вершину, то это означает, что мы нашли цикл (если граф неориентированный, то случаи, когда поиск в глубину из какой-то вершины пытается пойти в предка, не считаются).

```c++
#include <iostream>
#include <vector>

int n;
std::vector<vector<int>> graph;
std::vector<int> color;
std::vector<int> parent;
int cycle_start, cycle_end;

bool dfs(int vertex) {
  color[vertex] = 1;
  for (size_t i = 0; i < graph[vertex].size(); ++i) {
    int $to$  = graph[vertex][i];
    if (color[to] == 0) {
      parent[to] = vertex;
      if (dfs(to)) return true;
    }
    else if (color[to] == 1) {
      cycle_end = vertex;
      cycle_start = $to$ ;
      return true;
    }
  }
  color[vertex] = 2;
  return false;
}

int main() {
  // чтение графа

  parent.assign(n, -1);
  color.assign(n, 0);
  cycle_start = -1;
  for (int i = 0; i < n; ++i)
    if (dfs(i))
      break;

  if (cycle_st == -1)
    std::cout << "Acyclic" << "\n";
  else {
    std::cout << "Cyclic" << "\n";
    std::vector<int> cycle;
    cycle.push_back(cycle_start);
    for (int vertex = cycle_end; vertex != cycle_start; vertex = parent[vertex])
      cycle.push_back(vertex);
    cycle.push_back(cycle_start);
    reverse(cycle.begin(), cycle.end());
    for (size_t i = 0; i < cycle.size(); ++i)
      std::cout << cycle[i]+1 << " ";
  }
}
```

#### Топологическая сортировка

*Условие:*
Дан ориентированный граф с n вершинами и m рёбрами. Требуется перенумеровать его вершины таким образом, чтобы каждое рёбро вело из вершины с меньшим номером в вершину с большим. Иными словами, требуется найти перестановку вершин (топологический порядок), соответствующую порядку, задаваемому всеми рёбрами графа.
(**Топологическая сортировка** - упорядочивание вершин ациклического ориентированного графа согласно частичному порядку, заданному ребрами орграфа на множестве его вершин.)
Топологическая сортировка может быть не единственной (например, если граф — пустой; или если есть три такие вершины `a`, `b`, `c`, что из `a` есть пути в `b` и в `c`, но ни из `b` в `c`, ни из `c` в `b` добраться нельзя).

Топологической сортировки может не существовать вовсе — если граф содержит циклы (поскольку при этом возникает противоречие: есть путь и из одной вершины в другую, и наоборот).

```c++
#include <vector>

int n; // число вершин
std::vector<std::vector<int>> graph; // граф
std::vector<bool> visited;
std::vector<int> $to$ pological_sort;

void dfs (int vertex) {
  visited[vertex] = true;
  for (int u : graph[vertex])
    if (!visited[u] == 0)
      dfs(u);
  $to$ pological_sort.push_back(vertex);
}

void $to$ pological_sort() {
  visited.assign(n, false);
  answer.clear();
  for (int i = 0; i < n; ++i)
    if (!visited[i])
      dfs(i);
  reverse(answer.begin(), answer.end());
}
```

### 1.4. Нахождение компонент сильной связности. Алгоритм Косарайю с доказательством корректности(концепция). Алгоритм Тарьяна без доказательства корректности

#### Нахождение компонент сильной связности

*Условие:*

Дан ориентированный граф $G$, множество вершин которого $V$ и множество рёбер — $E$. Петли и кратные рёбра допускаются. Обозначим через $n$ количество вершин графа, через $m$ — количество рёбер.

*Решение:*

Напомним, что **компонентой сильной связности** (*strongly connected component*) называется такое (максимальное по включению) подмножество вершин $C4, что любые две вершины этого подмножества достижимы друг из друга, т.е. для любых $u,  $v$ \in C: u \rightarrow v,  $v$ \rightarrow u$, где символом $\rightarrow$ здесь и далее мы будем обозначать достижимость, т.е. существование пути из первой вершины во вторую. Понятно, что компоненты сильной связности для данного графа не пересекаются, т.е. фактически это разбиение всех вершин графа. Отсюда логично определение конденсации G как графа, получаемого из данного графа сжатием каждой компоненты сильной связности в одну вершину. Каждой вершине графа конденсации соответствует компонента сильной связности графа G, а ориентированное ребро между двумя вершинами $C_i$ и $C_j$ графа конденсации проводится, если найдётся пара вершин u из $C_i$, из $C_j$, между которыми существовало ребро в исходном графе, т.е. $(u, v)$ из $E$.

Важнейшим свойством графа конденсации является то, что он ацикличен. Действительно, предположим, что $C \rightarrow C'$, докажем, что $C' \mapsto C$. Из определения конденсации получаем, что найдутся две вершины $u$ из $C$ и $v$ из $C'$, что $u \rightarrow v$. Доказывать будем от противного, т.е. предположим, что $C' \rightarrow C$, тогда найдутся две вершины $u'$ из $C$ и $v'$ из $C'$, что $v' \rightarrow u'$. Но т.к. $u$ и $u'$ находятся в одной компоненте сильной связности, то между ними есть путь; аналогично для $v$ и $v'$. В итоге, объединяя пути, получаем, что $v \rightarrow u$, и одновременно $u \rightarrow v$. Следовательно, $u$ и $v$ должны принадлежать одной компоненте сильной связности, т.е. получили противоречие, что и требовалось доказать

#### Алгоритм Косарайю с доказательством корректности(концепция)

Алгоритм Косарайю предназначен для поиска компонент сильной связности в ориентированном графе и состоит из трёх шагов:

1. Выполнить поиск в глубину (DFS), пока не будут «помечены» все вершины. Вершина считается «помеченной», когда ей присвоено время выхода из рекурсии (см. основные понятия).

2. Инвертировать исходный граф

3. Выполнить DFS в порядке убывания пометок вершин.

Полученные деревья каждого такта DFS последнего шага являются компонентами сильной связности

**Доказательство корректности алгоритма:**

Немного уточним, что требуется доказать: Вершины $u$ и $v$ сильно связаны $\Leftrightarrow$ после выполнения алгоритма они принадлежат одному дереву такта DFS.

Если вершины u и  $v$ были сильно связаны в графе $G$, на третьем этапе будет найден путь из одной вершины в другую (по Лемме (Инвертирование рёбер цикла не влияет на его цикличность)), так как на первом шаге был найден путь $u \rightarrow v$, а на третьем - путь $v \rightarrow u$. Это означает, что по окончании алгоритма обе вершины лежат в одном дереве.

Вершины $u$ и $v$ лежат в одном и том же дереве поиска в глубину на третьем шаге алгоритма. Значит, они обе достижимы из корня $r$ этого дерева.

Вершина $r$ была рассмотрена на 3 шаге раньше всех, значит время выхода из неё на 1 шаге больше, чем время выхода из вершин $u$ и $v$. Из этого мы получаем 2 случая:

Обе эти вершины были достижимы из $r$ в исходном графе. Это означает сильную связность вершин $u$ и $r$ и сильную связность вершин $v$ и $r$ (по Лемме 3). Склеивая пути мы получаем связность вершин $u$ и $v$ (по Лемме 1)

Хотя бы одна вершина не достижима из $r$ в исходном графе, например $v$. Значит и $r$ была не достижима из $v$ в исходном графе, так как время выхода из $r$ — больше (если бы она была достижима, то время выхода из $v$ было бы больше, чем из $r$, просмотрите ещё раз первый шаг примера). Значит между этими вершинами нет пути (ни в исходном, ни в инвертированном графах), но последнего быть не может, потому что по условию  $v$ достижима из r на 3 шаге (в инвертированном графе)

Значит, из случая 1 и не существования случая 2 получаем, что вершины $u$ и $v$ сильно связаны в обоих графах

#### Алгоритм Тарьяна без доказательства корректности

Основой для алгоритма является структура данных "Система непересекающихся множеств", которая и была изобретена Тарьяном (Tarjan).

Алгоритм фактически представляет собой обход в глубину из корня дерева, в процессе которого постепенно находятся ответы на запросы. А именно, ответ на запрос $(v, u)$ находится, когда обход в глубину находится в вершине $u$, а вершина $v$ уже была посещена, или наоборот.

Итак, пусть обход в глубину находится в вершине $v$ (и уже были выполнены переходы в её сыновей), и оказалось, что для какого-то запроса $(v, u)$ вершина u уже была посещена обходом в глубину. Научимся тогда находить $LCA$ этих двух вершин.

Заметим, что $LCA(v, u)$ является либо самой вершиной $v$, либо одним из её предков. Получается, нам надо найти самую нижнюю вершину среди предков $v$ (включая её саму), для которой вершина u является потомком. Заметим, что при фиксированном $v$ по такому признаку (т.е. какой наименьший предок $v$ является и предком какой-то вершины) вершины дерева дерева распадаются на совокупность непересекающихся классов. Для каждого предка $p \neq v$ вершины $v$ её класс содержит саму эту вершину, а также все поддеревья с корнями в тех её сыновьях, которые лежат "слева" от пути до $v$ (т.е. которые были обработаны ранее, чем была достигнута $v$).

Нам надо научиться эффективно поддерживать все эти классы, для чего мы и применим структуру данных "Система непересекающихся множеств". Каждому классу будет соответствовать в этой структуре множество, причём для представителя этого множества мы определим величину **ANCESTOR** — ту вершину $p$, которая и образует этот класс.

Рассмотрим подробно реализацию обхода в глубину. Пусть мы стоим в некоторой вершине $v$. Поместим её в отдельный класс в структуре непересекающихся множеств, **ANCESTOR**[v] = $v$. Как обычно в обходе в глубину, перебираем все исходящие рёбра $(v, $to$ )$. Для каждого такого $to$ мы сначала должны вызвать обход в глубину из этой вершины, а потом добавить эту вершину со всем её поддеревом в класс вершины $v$. Это реализуется операцией **Union** структуры данных "система непересекающихся множеств", с последующей установкой **ANCESTOR** = $v$ для представителя множества (т.к. после объединения представитель класса мог измениться). Наконец, после обработки всех рёбер мы перебираем все запросы вида $(v, u)$, и если u была помечена как посещённая обходом в глубину, то ответом на этот запрос будет вершина $LCA(v,u)$ = **ANCESTOR**[FindSet(u)]. Нетрудно заметить, что для каждого запроса это условие (что одна вершина запроса является текущей, а другая была посещена ранее) выполнится ровно один раз.

Оценим асимптотику. Она складывается из нескольких частей. Во-первых, это асимптотика обхода в глубину, которая в данном случае составляет $O(n)$. Во-вторых, это операции по объединению множеств, которые в сумме для всех разумных n затрачивают $O(n)$ операций. В-третьих, это для каждого запроса проверка условия (два раза на запрос) и определение результата (один раз на запрос), каждое, опять же, для всех разумных n выполняется за $O(1)$. Итоговая асимптотика получается $O(n + m)$, что означает для достаточно больших $m$ $(n = O(m))$ ответ за $O(1)$ на один запрос

### 1.5. Компоненты реберной двусвязности. Мосты. Поиск мостов

#### Компоненты реберной двусвязности

> **Компонентами рёберной двусвязности** (англ. *costal doubly-linked components*) графа называют его подграфы, множества вершин которых - классы эквивалентности рёберной двусвязности, а множества рёбер - множества ребер из соответствующих классов эквивалентности.

#### Мосты

> **Мостом** называется такое ребро, удаление которого делает граф несвязным (или, точнее, увеличивает число компонент связности).

#### Поиск мостов

- Алгоритм:
    Запустим обход в глубину из произвольной вершины графа; обозначим её через **root**. Заметим следующий факт (который несложно доказать):

    Пусть мы находимся в обходе в глубину, просматривая сейчас все рёбра из вершины $v$. Тогда, если текущее ребро $(v,to)$ таково, что из вершины $to$ и из любого её потомка в дереве обхода в глубину нет обратного ребра в вершину  $v$ или какого-либо её предка, то это ребро является мостом. В противном случае оно мостом не является. (В самом деле, мы этим условием проверяем, нет ли другого пути из  $v$ в $to$ , кроме как спуск по ребру $(v,to)$ дерева обхода в глубину.)
    Теперь осталось научиться проверять этот факт для каждой вершины эффективно. Для этого воспользуемся "временами входа в вершину", вычисляемыми алгоритмом поиска в глубину.

    Итак, пусть $tin[v]$ — это время захода поиска в глубину в вершину $v$. Теперь введём массив $fup[v]$, который и позволит нам отвечать на вышеописанные запросы. Время $fup[v]$ равно минимуму из времени захода в саму вершину $tin[v]$, времён захода в каждую вершину $p$, являющуюся концом некоторого обратного ребра $(v, p)$, а также из всех значений $fup[to]$ для каждой вершины $to$ , являющейся непосредственным сыном $v$ в дереве поиска:

    $fup[v] = \min(tin[v], tin[p], fup(to))$ $(v, p)$ - back edge, $(v, to)$ - tree edge (здесь "back edge" — обратное ребро, "tree edge" — ребро дерева)

    Тогда, из вершины  $v$ или её потомка есть обратное ребро в её предка тогда и только тогда, когда найдётся такой сын $to$ , что $fup[to] \leq tin[v]$. (Если $fup[to] = tin[v]$, то это означает, что найдётся обратное ребро, приходящее точно в $v$; если же $fup[to] < tin[v]$, то это означает наличие обратного ребра в какого-либо предка вершины $v$.)

    Таким образом, если для текущего ребра $(v,to)$ (принадлежащего дереву поиска) выполняется $fup[to] > tin[v]$, то это ребро является мостом; в противном случае оно мостом не является.

### 1.6. Компоненты вершинной двусвязности. Точки сочленения. Поиск точек сочленения

#### Компоненты вершинной двусвязности

> **Компонентами вершинной двусвязности** графа, называют его подграфы, множества ребер которых — классы эквивалентности вершинной двусвязности, а множества вершин — множества всевозможных концов ребер из соответствующих классов.

#### Точки сочленения

> **Точкой сочленения** называется вершина, при удалении которой связный неориентированный граф становится несвязным.

#### Поиск точек сочленения

- Алгоритм:
    Запустим обход в глубину из произвольной вершины графа; обозначим её через $root$. Заметим следующий факт (который несложно доказать):

    Пусть мы находимся в обходе в глубину, просматривая сейчас все рёбра из вершины  $v \neq root$. Тогда, если текущее ребро $(v, to)$ таково, что из вершины $to$  и из любого её потомка в дереве обхода в глубину нет обратного ребра в какого-либо предка вершины v, то вершина  $v$ является точкой сочленения. В противном случае, т.е. если обход в глубину просмотрел все рёбра из вершины $v$, и не нашёл удовлетворяющего вышеописанным условиям ребра, то вершина $v$ не является точкой сочленения. (В самом деле, мы этим условием проверяем, нет ли другого пути из  $v$ в $to$ )
    Рассмотрим теперь оставшийся случай:  $v = root$. Тогда эта вершина является точкой сочленения тогда и только тогда, когда эта вершина имеет более одного сына в дереве обхода в глубину. (В самом деле, это означает, что, пройдя из $root$ по произвольному ребру, мы не смогли обойти весь граф, откуда сразу следует, что $root$ — точка сочленения).
    (Ср. формулировку этого критерия с формулировкой критерия для алгоритма поиска мостов.)

    Теперь осталось научиться проверять этот факт для каждой вершины эффективно. Для этого воспользуемся "временами входа в вершину", вычисляемыми алгоритмом поиска в глубину.

    Итак, пусть $tin[v]$ — это время захода поиска в глубину в вершину v. Теперь введём массив $fup[v]$, который и позволит нам отвечать на вышеописанные запросы. Время $fup[v]$ равно минимуму из времени захода в саму вершину $tin[v]$, времён захода в каждую вершину p, являющуюся концом некоторого обратного ребра $(v, p)$, а также из всех значений $fup[to]$ для каждой вершины $to$ , являющейся непосредственным сыном  $v$ в дереве поиска:

    $fup[v] = \min(tin[v], tin[p], fup(to))$ $(v, p)$ - back edge, $(v, to)$ - tree edge (здесь "back edge" — обратное ребро, "tree edge" — ребро дерева)

    Тогда, из вершины  $v$ или её потомка есть обратное ребро в её предка тогда и только тогда, когда найдётся такой сын $to$ , что $fup[to] < tin[v]$.

    Таким образом, если для текущего ребра $(v,to)$ (принадлежащего дереву поиска) выполняется $fup[to] \geq tin[v]$, то вершина  $v$ является точкой сочленения. Для начальной вершины  $v = root$ критерий другой: для этой вершины надо посчитать число непосредственных сыновей в дереве обхода в глубину.

### 1.7. Волновой алгоритм. Обход в ширину (применение очереди в волновом алгоритме)

#### Волновой алгоритм

> **Алгоритм волновой трассировки** (*волновой алгоритм*) — алгоритм поиска пути, алгоритм поиска кратчайшего пути на планарном графе. Принадлежит к алгоритмам, основанным на методах поиска в ширину.

Алгоритм предназначен для поиска кратчайшего пути от стартовой ячейки к конечной ячейке, если это возможно, либо, при отсутствии пути, выдать сообщение о непроходимости.

Работа алгоритма включает в себя три этапа: инициализацию, распространение волны и восстановление пути.

Инициализация

```c
Пометить стартовую ячейку 
d := 0 
```

Распространение волны

```c
ЦИКЛ
  ДЛЯ каждой ячейки loc, помеченной числом d
    пометить все соседние свободные непомеченные ячейки числом d + 1
  КЦ
  d := d + 1
ПОКА (финишная ячейка не помечена) И (есть возможность распространения волны) 
```

Восстановление пути

```c
ЕСЛИ финишная ячейка помечена
ТО
  перейти в финишную ячейку
  ЦИКЛ
    выбрать среди соседних ячейку, помеченную числом на 1 меньше числа в текущей ячейке
    перейти в выбранную ячейку и добавить её к пути
  ПОКА текущая ячейка — не стартовая
  ВОЗВРАТ путь найден
ИНАЧЕ
  ВОЗВРАТ путь не найден
```

#### Обход в ширину (применение очереди в волновом алгоритме)

> **Поиск в ширину** (англ. *breadth-first search*) — один из основных алгоритмов на графах, позволяющий находить все кратчайшие пути от заданной вершины и решать многие другие задачи.

- Описание алгоритма
    На вход алгоритма подаётся невзвешенный граф и номер стартовой вершины $s$. Граф может быть как ориентированным, так и неориентированным — для алгоритма это не важно.

    Основную идею алгоритма можно понимать как процесс «поджигания» графа: на нулевом шаге мы поджигаем вершину $s$, а на каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей, в конечном счете поджигая весь граф.

    Если моделировать этот процесс, то за каждую итерацию алгоритма будет происходить расширение «кольца огня» в ширину на единицу. Номер шага, на котором вершина  $v$ начинает гореть, в точности равен длине её минимального пути из вершины s.

```c++
std::vector<int> graph;

void bfs(int s) {
    std::queue<int> queue;
    queue.push(s);
    
    std::vector<int> depth(n, -1), parent(n);
    depth[s] = 0;
    
    while (!queue.empty()) {
        int vertex = queue.front();
        queue.pop();
        for (int u : g[vertex]) {
            if (depth[u] == -1) {
                queue.push(u);
                depth[u] = depth[vertex] + 1;
                parent[u] = vertex;
            }
        }
    }
} 
```

Теперь, чтобы восстановить кратчайший путь до какой-то вершины v, это можно сделать через массив p:

```c++
while (v != s) {
    std::cout << v << endl;
    v = p[v];
}
```

Обратим внимание, что путь выведется в обратном порядке.

### 1.8. Критерий существования Эйлерова пути и цикла в ориентированном и неориентированном графе. Поиск эйлерова пути и цикла

#### Критерий существования Эйлерова пути и цикла в неориентированном графе

- Согласно теореме, доказанной Эйлером, эйлеров цикл существует тогда и только тогда, когда
    1. Граф связный или будет являться связным, если удалить из него все изолированные вершины.
    2. В нём отсутствуют вершины нечётной степени.

- Эйлеров путь в графе существует тогда и только тогда, когда
    1. Граф связный
    2. Содержит не более двух вершин нечётной степени. Ввиду леммы о рукопожатиях, число вершин с нечётной степенью должно быть чётным. А значит эйлеров путь существует только тогда, когда это число равно нулю или двум. Причём, когда оно равно нулю, эйлеров путь вырождается в эйлеров цикл.

#### Критерий существования Эйлерова пути и цикла в ориентированном графе

- В ориентированном графе $G = (V, E)$ существует эйлеров цикл тогда и только тогда, когда:
    1. Входная степень любой вершины равна ее выходной степени.
    2. Все компоненты слабой связности кроме, может быть одной, не содержат ребер.
- В ориентированном графе $G = (V, E)$ существует эйлеров путь если:
    1. Входная степень любой вершины равна ее выходной степени, кроме двух вершин графа, для одной из которых (deg+) − (deg−) = 1, а для другой (deg+) − (deg−) = −1 .
    2. Все компоненты слабой связности кроме, может быть одной, не содержат ребер.

#### Поиск эйлерова пути и цикла

- Поиск эйлерова пути в графе
    Можно всегда свести задачу поиска эйлерова пути к задаче поиска эйлерова цикла. Действительно, предположим, что эйлерова цикла не существует, а эйлеров путь существует. Тогда в графе будет ровно 2 вершины нечётной степени. Соединим эти вершины ребром, и получим граф, в котором все вершины чётной степени, и эйлеров цикл в нём существует. Найдём в этом графе эйлеров цикл (алгоритмом, описанным ниже), а затем удалим из ответа несуществующее ребро.

- Поиск эйлерова цикла в графе
    Будем рассматривать самый общий случай — случай ориентированного мультиграфа, возможно, с петлями. Также мы предполагаем, что эйлеров цикл в графе существует (и состоит хотя бы из одной вершины). Для поиска эйлерова цикла воспользуемся тем, что эйлеров цикл — это объединение всех простых циклов графа. Следовательно, наша задача — эффективно найти все циклы и эффективно объединить их в один.

    Реализовать это можно, например, так, рекурсивно:

    ```c
    procedure find_all_cycles (v)
    var массив cycles
    1. пока есть цикл, проходящий через v, находим его
        добавляем все вершины найденного цикла в массив cycles (сохраняя порядок обхода)
        удаляем цикл из графа
    2. идем по элементам массива cycles
        каждый элемент cycles[i] добавляем к ответу
        из каждого элемента рекурсивно вызываем себя: find_all_cycles (cycles[i])
    ```

    Достаточно вызвать эту процедуру из любой вершины графа, и она найдёт все циклы в графе, удалит их из графа и объединит их в один эйлеров цикл.
    Для поиска цикла на шаге 1 используем поиск в глубину.
    Сложность полученного алгоритма — $O(|E|)$, то есть линейная относительно количества рёбер в данном графе
    