# Теория по алгоритмам:

## 1. Обходы графа
### 1.1. Ориентированный граф, псевдограф. Неориентированный граф, псевдограф. Связность в неор. графе, компоненты связности. Слабая и сильная связность в ор. графе. Компоненты слабой, сильной связности.
- Неориентированный граф - граф, ребра которого не имеют направления
- Ориентированный граф - граф, ребра которого имеют направление

- Псевдограф - граф с петлями
- Мультиграф - граф с кратными ребрами

Неориентированный граф G называется связным, если имеется путь между любыми двумя его различными вершинами

Связный подграф – часть графа, из любой вершины которого существует путь в любую другую.

Компонента связности графа G — максимальный (по включению) связный подграф графа G.
- Слабая связность - если вершины u, v становятся связными в графе G’, полученном из графа G удалением ориентации ребер
- Сильная связность - в графе G есть ор путь u->v и v->u.

Компонента слабой связности - множество (E’, V’) : для любых вершин u, v ∈ V’ существует путь u -> v по ребрам ∈ E’ в графе G’, полученном из G удалением ориентации ребер
Компонента сильной связности - множество (E’, V’) : для любых вершин u, v ∈ V’ существуют пути u -> v, v -> u по ребрам ∈ E’ в графе G
### 1.2. Обход в глубину. Цвета вершин. Времена входа и выхода. Лемма о белых путях(с доказательством).
Идея алгоритма: для каждой не пройденной вершины необходимо найти все не пройденные смежные вершины и повторить поиск для них
1) Выбираем любую вершину из не пройденных, обозначим ее u
2) Запускаем dfs(u)
  1) Пометим u как пройденную
  2) Для каждой не пройденной смежной с u вершиной (назовем ее v) запускаем dfs(v)
3) Повторяем шаги 1 и 2 пока все вершины не окажутся пройденными

Цвета вершин: (Нужно для поиска циклов)
- Белая - в ней еще не были
- Серая - проходится в текущей процедуре dfs
- Черная - вершина пройдена, все итерации dfs от нее завершены

#### Лемма о белых путях:
Не существует такого момента выполнения поиска в глубину, в который бы существовало ребро из черной вершины в белую.
#### Доказательство:
Пусть в процессе выполнения процедуры dfs нашлось ребро из черной вершины v в белую вершину u. Рассмотрим момент времени, когда мы запустили dfs(v). В этот момент вершина v была перекрашена из белого в серый, а вершина u была белая. Далее в ходе выполнения алгоритма будет запущен dfs(u), поскольку обход в глубину обязан посетить все белые вершины, в которые есть ребро из v. По алгоритму вершина v будет покрашена в черный цвет тогда, когда завершится обход всех вершин, достижимых из нее по одному ребру, кроме тех, что были рассмотрены раньше нее. Таким образом, вершина v может стать черной только тогда, когда dfs выйдет из вершины u, и она будет покрашена в черный цвет. Получаем противоречие.
### 1.3. Проверка связности неориентированного графа. Поиск цикла в неориентированном и ориентированном графе. Топологическая сортировка.
#### Проверка связности неорграфа:
Для решения задачи модифицируем обход в глубину так, чтобы запустившись от вершины какой-то компоненты, от пометил все вершины этой компоненты — то есть все достижимые вершины — заданным номером этой компоненты.
#### Асимптотика: O(|V|+|E|).

#### Поиск цикла в неориентированном и ориентированном графе:
- В случае ориентированного графа произведём серию обходов dfs. То есть из каждой вершины, в которую мы ещё ни разу не приходили, запустим поиск в глубину, который при входе в вершину будет красить её в серый цвет, а при выходе из неё — в чёрный. И, если алгоритм пытается пойти в серую вершину, то это означает, что цикл найден.
- В случае неориентированного графа, одно ребро не должно встречаться в цикле дважды по определению. Поэтому необходимо дополнительно проверять, что текущее рассматриваемое из вершины ребро не является тем ребром, по которому мы пришли в эту вершину.
#### Асимптотика: O(|V|+|E|).

#### Топологическая сортировка.
Указать такой линейный порядок на вершинах ациклического орграфа, чтобы любое ребро вело от вершины с меньшим номером к вершине с большим номером. Запускаем dfs, и когда вершина обработана, заносим ее в стек. По окончании обхода в глубину вершины достаются из стека. Новые номера присваиваются в порядке вытаскивания из стека.
### 1.4. Нахождение компонент сильной связности. Алгоритм Косарайю с доказательством корректности(концепция). Алгоритм Тарьяна без доказательства корректности.
#### Алгоритм Косарайю:
1. Выполнить поиск в глубину (DFS), пока не будут «помечены» все вершины. Вершина считается «помеченной», когда ей присвоено время выхода из рекурсии.
2. Инвертировать исходный граф
3. Выполнить DFS в порядке убывания пометок вершин.
#### Доказательство:
Вершины u и v сильно связаны ⇔ после выполнения алгоритма они принадлежат одному дереву такта DFS
#### ⇒:
Если вершины u и v были сильно связаны в графе G, на третьем этапе будет найден путь из одной вершины в другую (по Лемме 3), так как на первом шаге был найден путь u→v, а на третьем -- путь v→u. Это означает, что по окончании алгоритма обе вершины лежат в одном дереве.
#### ⇐:
Вершины u и v лежат в одном и том же дереве поиска в глубину на третьем шаге алгоритма. Значит, они обе достижимы из корня r этого дерева. Вершина r была рассмотрена на 3 шаге раньше всех, значит время выхода из неё на 1 шаге больше, чем время выхода из
вершин u и v. Из этого мы получаем 2 случая:
1. Обе эти вершины были достижимы из r в исходном графе. Это означает сильную связность вершин u и r и сильную связность вершин v и r. Склеивая пути мы получаем связность вершин u и v
2. Хотя бы одна вершина не достижима из r в исходном графе, например v. Значит и r была не достижима из v в исходном графе, так как время выхода из r — больше. Значит между этими вершинами нет пути, но последнего быть не может, потому что по условию v достижима из r на 3 шаге.

Значит, из случая 1 и не существования случая 2 получаем, что вершины u и v сильно связаны в обоих графах
### 1.5. Компоненты реберной двусвязности. Мосты. Поиск мостов.
Пусть G - неорграф, говорим, что вершины u,v реберно двусвязны, если между u, v существует два пути, которые не имеют общих ребер.
#### Алгоритм поиска компонент реберной двусвязности:
- Первый проход: запустим алгоритм поиска мостов, чтобы посчитать две величины: tin(v) и up(v).
- Второй проход: окрашиваем вершины, т.е. если перешли по мосту, то оказались в новой компоненте рёберной двусвязности.

Мост - ребро, удаление которого делает связный граф несвязным.
#### Поиск мостов:
Запустим dfs из произвольной вершины графа root.

Пусть мы находимся в обходе в глубину, просматривая сейчас все рёбра из вершины v. Тогда, если текущее ребро (v, to) таково, что из вершины to и из любого её потомка в дереве обхода в глубину нет обратного ребра в вершину v или какого-либо её предка, то это ребро является мостом.

Итак, пусть tin[v] — это время захода dfs в вершину v. 

Теперь введём массив fup[v]. Время fup[v] равно min из времени захода в саму вершину tin[v], времён захода в каждую вершину p, являющуюся концом некоторого обратного ребра (v,p), а также из всех значений fup[to] для каждой вершины to, являющейся непосредственным сыном v в дереве поиска:

fup[v] = min{tin[v], tin[p]: for all (v, p) - back edge, fup[to]: for all (v, to) - tree edge}

Тогда, из вершины v или её потомка есть обратное ребро в её предка тогда и только тогда, когда найдётся такой сын to, что fup[to]<=tin[v].

Таким образом, если для текущего ребра (v, to) выполняется fup[to]>tin[v], то это ребро является мостом; в противном случае оно мостом не является.

Нужно уметь различать три случая: когда мы идём по ребру дерева поиска в глубину, когда идём по обратному ребру, и когда пытаемся пойти по ребру дерева в обратную сторону. Это, соответственно, случаи:
• used[to]=false — критерий ребра дерева поиска
• used[to]=true and to≠parent — критерий обратного ребра
• used[to]=true and to=parent — критерий прохода по ребру дерева поиска в обратную сторону

Таким образом, для реализации этих критериев нам надо
передавать в функцию поиска в глубину вершину-предка
текущей вершины.
### 1.6. Компоненты вершинной двусвязности. Точки сочленения. Поиск точек сочленения.
Два ребра графа называются вершинно двусвязными, если существуют вершинно непересекающиеся пути, соединяющие их концы.

#### Алгоритм поиска компонент вершинной двусвязности:
- Первый проход: ищем точки сочленения с помощью обхода в глубину, заполняем массивы tin, fup.
- Второй проход: точка сочленения принадлежит как минимум двум компонентам вершинной двусвязности. Вершина v≠root является точкой сочленения, если у нее есть сын u, такой что fup[u]>=tin[v]. Это также значит, что ребро (v, u) содержится в другой компоненте вершинной двусвязности, нежели ребро по которому мы пришли в вершину v, используя поиск в глубину. Получается, что перейдя по этому ребру, мы окажемся в другой компоненте вершинной двусвязности. Используем это свойство, чтобы окрасить компоненты вершинной двусвязности в различные цвета.

Точкой сочленения называется вершина, удаление которой делает граф несвязным.

Рассмотрим ребро между вершинами v и u. Тогда если из вершины u и ее потомков нельзя попасть в какого-либо предка вершины v и притом вершина v не является корнем дерева, то данная вершина и есть точка сочленения. Если вершина v - корень дерева, то она является точкой сочленения тогда и только тогда, когда эта точка имеет более одного сына в обходе графа в глубину.
#### Алгоритм поиска точек сочленения:
Итак, пусть tin[v] — это время захода поиска в глубину в вершину v. Теперь введём массив fup[v]. Время fup[v] равно минимуму из времени захода в саму вершину tin[v], времён захода в каждую вершину p, являющуюся концом некоторого обратного ребра (v,p), а также из всех значений fup[to] для каждой вершины to, являющейся непосредственным сыном v в дереве поиска:

fup[v] = min{tin[v], tin[p]: for all (v, p) - back edge, fup[to]: for all (v, to) - tree edge}

Тогда, из вершины v или её потомка есть обратное ребро в её предка тогда и только тогда, когда найдётся такой сын to, что fup[to]<tin[v].

Таким образом, если для текущего ребра (v,to) (принадлежащего дереву поиска) выполняется fup[to]>=tin[v], то вершина v является точкой сочленения. Для начальной вершины v=root критерий другой: для этой вершины надо посчитать число непосредственных сыновей в дереве обхода в глубину.
### 1.7. Волновой алгоритм. Обход в ширину (применение очереди в волновом алгоритме).
#### Волновой алгоритм поиска кратчайшего пути:
Если ищем все кратчайшие пути из вершины v:
1. Расстояние до v, dist(v)=0
2. Расстояние до всех соседних вершин dist(v)=min(1,dist(u))
3. Расстояние до соседей соседей dist(v)=min(2,dist(u))
И т д пока на очередной итерации веса не обновятся.
#### Обход в ширину (применение очереди в волновом алгоритме):
Пусть задан невзвешенный ориентированный граф G =(V,E), в котором выделена исходная вершина s. Требуется найти длину кратчайшего пути (если таковой имеется) от одной заданной вершины до другой.

Для алгоритма нам потребуются очередь и множество посещенных вершин visited, которые изначально содержат одну вершину s . На каждом шагу алгоритм берет из начала очереди вершину v и добавляет все непосещенные смежные с v вершины в visited и в конец очереди. Если очередь пуста, то алгоритм завершает работу.
### 1.8. Критерий существования Эйлерова пути и цикла в ориентированном и неориентированном графе. Поиск эйлерова пути и цикла.
Эйлеров путь - путь в графе, проходящий через все его рёбра по одному разу.
- В неориентированном графе эйлеров путь существует тогда и только тогда, когда количество вершин с нечётными степенями равно двум.
- В ориентированном графе существует эйлеров путь если входная степень любой вершины равна ее выходной степени, кроме двух вершин графа, для одной из которых deg+−deg−=1, а для другой deg+−deg−=-1.
#### Поиск эйлерова пути: procedure FindEulerPath (V)
1. перебрать все рёбра, выходящие из вершины V; каждое такое ребро удаляем из графа, и вызываем FindEulerPath из второго конца этого ребра;
2. добавляем вершину V в ответ.

Эйлеров цикл - это эйлеров путь, являющийся циклом.
- В неориентированном графе эйлеров цикл существует тогда и только тогда, когда степени всех вершин чётны.
- В ориентированном графе существует эйлеров цикл, если входная степень любой вершины равна ее выходной степени.
#### Поиск эйлерова цикла:
Перед запуском алгоритма необходимо проверить граф на эйлеровость.

Чтобы построить Эйлеров путь, нужно запустить алгоритм из вершины с нечетной степенью.

Алгоритм напоминает поиск в глубину. Главное отличие состоит в том, что пройденными помечаются не вершины, а ребра графа. Начиная со стартовой вершины v строим путь, добавляя на каждом шаге не пройденное еще ребро, смежное с текущей вершиной. Вершины пути накапливаются в стеке S.

Когда наступает такой момент, что для текущей вершины w все инцидентные ей ребра уже пройдены, записываем вершины из S в ответ, пока не встретим вершину, которой инцидентны не пройденные еще ребра. Далее продолжаем обход по не посещенным ребрам

## 2. Планарность графа
### 2.1. Формула Эйлера. Теорема Портнягина-Куратовского. Теорема Вагнера.
Граф обладает укладкой в пространстве L, если он изоморфен графу, вершинами которого являются некоторые точки пространства, а ребрами — кривые, соединяющие соответствующие вершины, причем
1. Кривая, являющаяся ребром не проходит через другие вершины графа, кроме вершин, которые она соединяет;
2. Две кривые, являющиеся ребрами, пересекаются лишь в вершинах, инцидентных одновременно обоим этим ребрам.

Соответствующий граф, составленный из точек пространства и жордановых кривых из L , называют укладкой исходного графа. Граф называется планарным, если он обладает укладкой на плоскости. Плоским называется граф уже уложенный на плоскости.
#### Формула Эйлера для плоских графов:
Для произвольного плоского связного графа G с V вершинами, E ребрами и F гранями справедливо следующее соотношение: V−E+F=2
#### Теорема Портнягина-Куратовского:
Граф планарен тогда и только тогда, когда он не содержит подграфов, гомеоморфных K5 или K3,3.
#### Теорема Вагнера:
Любой граф либо имеет планарное вложение, либо содержит минор одного из двух типов — полный граф K5 или полный двудольный граф K3,3 (граф может иметь оба типа миноров). (Если по-русски: любой граф либо планарен либо сводим стягиванием вершин (когда ребро удаляется, а вершины, инциденты ребру стягиваются в одну) к графу К5 и/или К3,3)
### 2.2. Гамма алгоритм. Контактная вершина.
На вход алгоритму подаются графы со следующими свойствами:
1. Граф связный.
2. Граф содержит хотя бы один цикл.
3. Граф не имеет мостов.

Уже уложенную во время работы алгоритма часть будем обозначать Gplane

Построим множество сегментов. Каждый сегмент S относительно уже построенного Gplane представляет собой одно из двух:
1. ребро, оба конца которого принадлежат Gplane, но само оно не принадлежит Gplane
2. связную компоненту графа G∖Gplane, дополненную всеми ребрами графа G такими, у которых один из концов принадлежит связной компоненте, а второй принадлежит графу Gplane

Вершины, одновременно принадлежащие Gplane и какому-либо сегменту, назовем контактными.

Пусть грань Γ вмещает сегмент S, если номера всех контактных вершин S принадлежат этой грани, S⊂Γ. Очевидно, таких граней может быть несколько. Множество таких граней обозначим Γ(S) ,а их число —|Γ(S)|
#### Алгоритм:
1. Инициализация. Выбирается простой цикл в исходном графе и изображается на плоскости.
2. Общий шаг. Этот шаг повторяется до тех пор, пока граф не будет уложен или пока не будет получено, что граф не планарен.
  - строится множество сегментов
  - для каждого сегмента вычисляется величина|Γ(S)|. Если существует i: |Γ(Si)|=0, то граф не планарен, алгоритм завершает работу.
  - выбирается сегмент с минимальным числом |Γ(Si)|
  - в этом сегменте выбирается цепь между двумя контактными вершинами
  - эта цепь укладывается в любую грань, вмещающую данный сегмент
3. Либо получена плоская укладка графа, либо граф
оказался не планарен.
### 2.3. Теорема о корректности Гамма алгоритма. Асимптотика алгоритма.

## 3. Кратчайшие пути во взвешенном графе.
### 3.1. Алгоритм Дейкстры. Доказательство корректности(с доказательством) Оценка времени работы. Дерево кратчайших путей.
#### Задача:
Для заданного взвешенного графа G=(V,E) найти кратчайшие пути из заданной вершины до всех остальных вершин. Веса всех рёбер неотрицательны.
#### Алгоритм Дейкстры:
Заведём массив d, в котором для каждой вершины v будем хранить текущую длину d[v] кратчайшего пути из s в v. Изначально d[s]=0, а для всех остальных вершин эта длина равна бесконечности. Кроме того, для каждой вершины v будем хранить, помечена она ещё или нет. Изначально все вершины не помечены.

Сам алгоритм состоит из n итераций. На очередной итерации выбирается вершина v с наименьшей величиной d[v] среди ещё не помеченных.

Выбранная таким образом вершина v отмечается помеченной. Далее, на текущей итерации, из вершины v производятся релаксации: просматриваются все рёбра (v, to), исходящие из вершины v, и для каждой такой вершины to алгоритм пытается улучшить значение d[to]. Пусть длина текущего ребра равна len, тогда в виде кода релаксация выглядит как: d[to] = min(d[to], d[v]+len)

На этом текущая итерация заканчивается, алгоритм переходит к следующей итерации. При этом после n итераций, все вершины графа станут помеченными, и алгоритм свою работу завершает.

Пусть G=(V,E) — ориентированный взвешенный граф, вес рёбер которого неотрицателен, s-стартовая вершина. Тогда после выполнения алгоритма Дейкстры d(u)=ρ(s,u) для всех u, где ρ(s,u)— длина кратчайшего пути из вершины S в вершину u.
#### Доказательство: по индукции, что в момент посещения любой вершины d(u)=ρ(s,u).
- На первом шаге выбирается s, для неё выполнено: d(s)=ρ(s,s)=0
- Пусть для n первых шагов алгоритм сработал верно и на n+1 шагу выбрана вершина u. Докажем, что в этот момент d(u)=ρ(s,u). Для начала отметим, что для любой вершины v, всегда выполняется d(v)⩾ρ(s,v). Пусть P - кратчайший путь из s в u, v-первая непосещённая вершина на P, z-предшествующая ей. Поскольку путь P кратчайший, его часть, ведущая из s через z в v, тоже кратчайшая, следовательно ρ(s,v)=ρ(s,z)+w(z,v). По предположению индукции, в момент посещения вершины z выполнялось d(z)=ρ(s,z), следовательно, вершина v тогда получила метку не больше чем d(z)+w(zv)=ρ(s,z)+w(zv)=ρ(s,v), следовательно, d(v)=ρ(s,v). С другой стороны, поскольку сейчас мы выбрали вершину u, её метка минимальна среди непосещённых, то есть d(u)⩽d(v)=ρ(s,v)⩽ρ(s,u), где второе неравенсто верно из-за ранее упомянутого определения вершины v в качестве первой непосещённой вершины на P, то есть вес пути до промежуточной вершины не превосходит веса пути до конечной вершины вследствие неотрицательности весовой функции. Комбинируя это с d(u)⩾ρ(s,u), имеем d(u)=ρ(s,u), что и требовалось доказать.
- Поскольку алгоритм заканчивает работу, когда все вершины посещены, в этот момент d(u)=ρ(s,u) для всех u.
#### Асимптотика:
| реализация | поиск min | релаксация | общее | описание |
| ---------- | --------- | ---------- | ----- | -------- |
| наивная реализация | O(n) | O(1) | O(n^2 + m) | n раз осуществляем поиск вершины с минимальной величиной d среди O(n) непомеченных вершин и m раз проводим релаксацию за O(1). Для плотных графов (m≈n2) данная асимптотика является оптимальной |
| двоичная куча | O(log n) | O(log n) | O(m log n) | используя двоичную кучу можно выполнять операции извлечения минимума и обновления элемента за O(logn). Тогда время работы алгоритма Дейкстры составит O(nlogn+mlogn)=O(mlogn) |
| фибоначчиева куча | O(log n) | O(1) | O(n log n + m) | используя Фибоначчиевы кучи можно выполнять операции извлечения минимума за O(logn) и обновления элемента за O(1). Таким образом, время работы алгоритма составит O(nlogn+m) |
### 3.2. Потенциалы. Условие применимости алгоритма Дейкстры для измененных длин ребер. Потенциал π(v) = ρ(v, t).) = ρ(v) = ρ(v, t)., t).

### 3.3. Алгоритм A*. Условие монотонности на эвристику. Примеры эвристик.
#### Алгоритм A*:
Дейкстра с модифицированным расстоянием d(v) = f(v)+h(v), где f(v) - расстояние = сумме длин ребер до вершины v. h(v) - эвристика стоимости пути от v до конечной цели t. Приоритет - расстояние d(v) для всех вершин.

Чтобы A* был оптимален, выбранная функция h(v) должна быть допустимой эвристической функцией.

Говорят, что эвристическая оценка h(v) допустима, если для любой вершины v значение h(v) меньше или равно весу кратчайшего пути от v до цели.

Свойство монотонности означает, что если существуют пути A—B—C и A—C (не обязательно через B), то оценка стоимости пути от A до C должна быть меньше либо равна сумме оценок путей A—B и B—C.

Примеры эвристик:
- Если мы можем перемещаться в четырех направлениях, то в качестве эвристики стоит выбрать манхэттенское расстояние h(v)=|v.x−goal.x|+|v.y−goal.y|
- Расстояние Чебышева применяется, когда к четырем направлениям добавляются диагонали: h(v)=max(|v.x−goal.x|,|v.y−goal.y|)
- Если передвижение не ограничено сеткой, то можно использовать евклидово расстояние по прямой: h(v)= √{(v.x−goal.x)**2+(v.y−goal.y)**2}
### 3.4. Алгоритм Форда-Беллмана. Хранение в матрице: Dv) = ρ(v, t).k равно длине кратчайшего пути до вершины v) = ρ(v, t). за ровно k ребер (не более k ребер). Доказательство корректности(полное). Оценка времени работы.
Работает на графах с отрицательными весами. Находит кратчайшее расстояние от вершины s до всех остальных
#### Алгоритм Форда-Беллмана:
d[s] = 0
d[v] = inf, v != s
for k = 1 ... n-1
    for uv ∈ E:
        d[v] = min{d[v], d[u] + w(u,v)}
#### Доказательство:
На k - ой итерации d[v] - длина какого-то пути <= длине кратчайшего пути, состоящего из <= k ребер

Рассмотрим произвольную вершину v, до которой существует путь из стартовой вершины s, и рассмотрим кратчайший путь до неё: (p0=s, p1, ... , pk=v). Перед первой фазой кратчайший путь до вершины p0=s найден корректно. Во время первой фазы ребро (p0,p1) было просмотрено алгоритмом Форда-Беллмана, следовательно, расстояние до вершины p1 было корректно посчитано после первой фазы. Повторяя эти утверждения k раз, получаем, что после k-й фазы расстояние до вершины pk=v посчитано корректно, ч т д.

Любой кратчайший путь не может иметь более n-1 ребра. Следовательно, алгоритму достаточно произвести только n-1 фазу.

Можно хранить матрицу d[s][k] – кратчайший путь в s, длиной не более k шагов.
### 3.5. Восстановление пути. Детектирование цикла отрицательного веса. Поиск самого цикла.
#### Восстановление пути:
Для этого заведём ещё один массив p[0..n-1], в котором для каждой вершины будем хранить её "предка", т.е. предпоследнюю вершину в кратчайшем пути, ведущем в неё.
#### Детектирование цикла отрицательного веса:
Если после n-1 фазы мы выполним ещё одну фазу, и на ней произойдёт хотя бы одна релаксация (уменьшение расстояния до вершины), то граф содержит цикл отрицательного веса.
#### Поиск самого цикла:
Для этого достаточно запомнить номер вершины x, в которой произошла релаксация на n-ой фазе. Эта вершина будет либо лежать на цикле отрицательного веса, либо она достижима из него. Чтобы получить вершину, которая гарантированно лежит на цикле, достаточно, например, n раз пройти по предкам, начиная от вершины x. Получив номер y вершины, лежащей на цикле, надо пройтись от этой вершины по предкам, пока мы не вернёмся в эту же вершину y (а это обязательно произойдёт, потому что релаксации в цикле отрицательного веса происходят по кругу)
### 3.6. Нахождение кратчайших путей с учетом циклов отрицательного веса.
### 3.7. Алгоритм Флойда-Уоршелла. Доказательство (концепция). Восстановление пути.
Находит кратчайшие расстояния между всеми парами вершин в графе с отрицательными весами ребер.
#### Алгоритм Флойда-Уоршелла:
let dist be a |V| × |V| массив минимальных расстояний, инициализированный как ∞ (бесконечность)

for each edge (u, v) do
    dist[u][v] ← w(u, v) // Вес ребра (u, v)
for each vertex v do
    dist[v][v] ← 0
for k from 1 to |V|
    for i from 1 to |V|
        for j from 1 to |V|
            if dist[i][j] > dist[i][k] + dist[k][j]
                dist[i][j] ← dist[i][k] + dist[k][j]
            end if
#### Доказательство:

#### Восстановление пути:
Алгоритм Флойда легко модифицировать таким образом, чтобы он возвращал не только длину кратчайшего пути, но и сам путь. Для этого достаточно завести дополнительный массив next, в котором будет храниться номер вершины, в которую надо пойти следующей, чтобы дойти из u в v по кратчайшему пути.

func floyd(w):
    d = ω ( ω(u,v) = w(u,v)/INF )
    for i∈V
        for u∈V
            for v∈V
                if d[u][i] + d[i][v] < d[u][v]
                    d[u][v] = d[u][i] + d[i][v]
                    next[u][v] = next[u][I]

func getShortestPath(u, v):
    if d[u][v] == ∞
        print "No path found"
    c = u
    while c != v
        print c
        c = next[c][v]
    print v
### 3.8. Нахождение цикла отрицательного веса.
Есть цикл отрицательного веса, если на диагонали матрицы d появилось отрицательное значение.

Для тех пар вершин i и j, между которыми нельзя зайти в цикл отрицательного вес, алгоритм отработает корректно. Для тех же пар вершин, ответа для которых не существует, алгоритм Флойда найдёт в качестве ответа какое-то число.

Тем не менее, можно улучшить алгоритм Флойда, чтобы он аккуратно обрабатывал такие пары вершин и выводил для них, например, -INF.

Между вершинами i и j не существует кратчайшего пути тогда и только тогда, когда найдётся такая вершина t, достижимая из i и из которой достижима j, для которой выполняется d[t][t]<0.
### 3.9. Алгоритм Джонсона. Добавление фиктивного корня и фиктивных ребер для запуска алгоритма Форда-Беллмана.
Находит кратчайшие пути между всеми парами вершин во взвешенном ориентированном графе с любыми весами ребер, но не имеющем отрицательных циклов.

В этом алгоритме используется метод изменения веса. Суть его заключается в том, что для заданного графа G строится новая весовая функция ωφ, неотрицательная для всех ребер графа G и сохраняющая кратчайшие пути. Такая весовая функция строится с помощью так называемой потенциальной функции.

Пусть φ:V→ℝ— произвольное отображение из множества вершин в вещественные числа. Тогда новой весовой функцией будет ω(u,v)=ω(u,v)+φ(u)−φ(v). Такая потенциальная функция строится добавлением фиктивной вершины s в G, из которой проведены ориентированные ребра нулевого веса во все остальные вершины графа, и запуском алгоритма Форда-Беллмана из нее (φ(v) будет равно длине кратчайшего пути из s в v). На этом же этапе мы сможем обнаружить наличие отрицательного цикла в графе.

Теперь, когда мы знаем, что веса всех ребер неотрицательны, и кратчайшие пути сохранятся, можно запустить алгоритм Дейкстры из каждой вершины и таким образом найти кратчайшие расстояния между всеми парами вершин.

#### Асимптотика:
Алгоритм Джонсона работает за O(VE+VD), где O(D)— время работы алгоритма Дейкстры. Если в алгоритме Дейкстры неубывающая очередь с приоритетами реализована в виде фибоначчиевой кучи, то время работы алгоритма Джонсона есть O(V^2logV+VE). В случае реализации очереди с приоритетами в виде двоичной кучи время работы равно O(VElogV).

## 4. Остовные деревья
### 4.1. Остовное дерево. Построение с помощью обхода в глубину и в ширину.
Остовное дерево графа G=(V,E) это ациклический связный подграф данного связного неориентированного графа, в который входят все его вершины.

Остовное дерево может быть построено практически любым алгоритмом обхода графа, например поиском в глубину или поиском в ширину. Оно состоит из всех пар рёбер (u,v), таких, что алгоритм, просматривая вершину u, обнаруживает в её списке смежности новую, не обнаруженную ранее вершину v.
### 4.2. Определение минимального остовного дерева.
Минимальное остовное дерево графа G=(V,E) это его ациклический связный подграф, в который входят все его вершины, обладающий минимальным суммарным весом ребер.
### 4.3. Теорема о разрезе. Доказательство.
Ребро (u,v) не принадлежащее G’ называется безопасным, если при добавлении его в G’, G’ и {(u,v)} также является подграфом некоторого MST графа G.

#### Лемма:
Рассмотрим связный неориентированный взвешенный граф G=(V,E) с весовой функцией w: E->R. Пусть G’ = (V, E’) - подграф некоторого MST G. <S,T> - разрез G: ни одно ребро из E’ не пересекает разрез, а (u,v) - ребро минимального веса среди всех ребер, пересекающих разрез <S,T>. Тогда (u,v) является безопасным ребром.
#### Доказательство:
Достроим Е’ до некоторого Tmin(MST).

Возможно 2 случая:
1) e = (u,v) ∈ Tmin - доказано
2) e ∉ Tmin, тогда рассмотрим путь от u до v. Так как они лежат в разных долях, то существует хотя бы одно ребро e’, пересекающее разрез. По условию леммы w(e)<=w(e’). Заменим e’ на e. Т к вес остова не увеличился => E’и {e} -> MST -> e - безопасное ребро.
### 4.4. Алгоритм Прима. Аналогия с алгоритмом Дейкстры. Оценка времени работы для различных реализаций очереди с приоритетом: бинарная куча, Фибоначчиева куча (последнее без доказательства).
#### Алгоритм Прима:
Данный алгоритм очень похож на алгоритм Дейкстры. На вход алгоритма подаётся связный неориентированный граф. Для каждого ребра задаётся его стоимость.

Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.

Результатом работы алгоритма является остовное дерево минимальной стоимости.
#### Асимптотика:
Асимптотика алгоритма зависит от способа хранения графа и способа хранения вершин, не входящих в дерево.
- Если приоритетная очередь Q реализована как обычный массив d, то Extract.Min(Q) выполняется за O(n), а стоимость операции d[u] <— w(v,u) составляет O(1).
- Если Q представляет собой бинарную пирамиду, то стоимость Extract.Min(Q) снижается до O(log n), а стоимость d[u] <— w(v,u) возрастает до O(log n).
- При использовании фибоначчиевых пирамид операция Extract.Min(Q) выполняется за O(log n) , а d[u] <— w(v,u) за O(1).

| представление priority queue и графа | асимптотика |
| ------------- | ----------- |
| массив, список (матрица) | O(V^2) |
| бинарная пирамида, списки | O((V+E) log V)=O(E log V) |
| фибоначчиевые кучи, списки | O(E + V log V) |

### 4.5. Алгоритм Прима. Доказательство корректности с помощью теоремы о разрезе.
### Доказательство:
На очередном шаге вытаскиваем самое легкое ребро между разрезом <A,B>. По лемме о безопасном ребре это ребро безопасно. Алгоритм, добавляющий |V|-1 раз безопасное ребро, корректен.
### 4.6. Алгоритм Крускала. Доказательство корректности. Оценка времени работы.

### 4.7. Система непересекающихся множеств. Эвристика потенциалов без доказательства. Эвристика сжатия пути без доказательства. Почти константное время работы(без доказательства).
Задача: создать быструю структуру, которая поддерживает следующие операции:
- MakeSet(X) — внести в структуру новый элемент X, создать для него множество размера 1 из самого себя.
- Find(X) — возвратить идентификатор множества, которому принадлежит элемент X.
- Unite(X, Y) — объединить два множества, в которых лежат элементы X и Y, в одно новое.

Хранить структуру данных будем в виде леса. Все элементы одного множества лежат в одном соответствующем дереве, представитель дерева — его корень, слияние множеств суть просто объединение двух деревьев в одно.
#### Эвристика сжатия путей:
Суть эвристики: после того, как корень будет найден, мы для каждой вершины по пути от X к корню изменим предка на этого самого представителя. То есть фактически переподвесим все эти вершины вместо длинной ветви непосредственно к корню.
#### Эвристика рангов:
Будем хранить помимо предков еще один массив Rank. В нем для каждого дерева будет храниться верхняя граница его высоты — то есть длиннейшей ветви в нем. Заметьте, не сама высота — в процессе выполнения Find длиннейшая ветвь может самоуничтожиться, а тратить еще итерации на нахождение новой длиннейшей ветви слишком дорого. Поэтому для каждого корня в массиве Rank будет записано число, гарантированно больше или равное высоте его дерева.

Теперь легко принять решении о слиянии: чтобы не допустить слишком длинных ветвей, будем подвешивать более низкое дерево к более высокому.

При совместном применении эвристик сжатия пути и объединения по рангу время работы на один запрос получается O(a(n)) в среднем, где a(n) — обратная функция Аккермана, которая растёт очень медленно, настолько медленно, что для всех разумных ограничений n она не превосходит 4.Именно поэтому про асимптотику работы системы непересекающихся множеств уместно говорить "почти константное время работы".
### 4.8. Алгоритм Борувки. Доказательство(полное). Оценка времени работы.
Алгоритм Борувки состоит из нескольких шагов:
1. Изначально каждая вершина графа G — тривиальное дерево, а ребра не принадлежат никакому дереву.
2. Для каждого дерева T найдем минимальное инцидентное ему ребро. Добавим все такие ребра.
3. Повторяем шаг 2 пока в графе не останется только одно дерево T.

Данный алгоритм может работать неправильно, если в графе есть ребра равные по весу. Например, полный граф из трех вершин, вес каждого ребра равен один. В T могут быть добавлены все три ребра. Избежать эту проблему можно, например, выбирая в первом пункте среди ребер, равных по весу, ребро с наименьшим номером.

Доказательство корректности:

Очевидно, что в результате работы алгоритма получается дерево. Пусть T — минимальное остовное дерево графа G , а T′ — дерево полученное после работы алгоритма. Покажем, что T=T′.

Предположим обратное T≠T′. Пусть ребро e′ — первое добавленное ребро дерева T′, не принадлежащее дереву T. Пусть P — путь, соединяющий в дереве T вершины ребра e′. Понятно, что в момент, когда ребро e′ добавляли, какое-то ребро e не было добавлено. По алгоритму w(e)⩾w(e′). Однако тогда T−e+e′ — остовное дерево веса не превышающего вес дерева T. Получили противоречение.
Следовательно T=T′.

Асимптотика:

На i-ой итерации внешнего цикла каждая компонента состоит как минимум из двух компонент из (i−1)-й итерации. Значит, на каждой итерации число компонент уменьшается как минимум в 2 раза. Тогда внешний цикл повторяется O(logV) раз, так как количество компонент изначально равно количеству вершин. Что же касается внутреннего цикла, то он выполняется за O(E), где E — количество рёбер в исходном графе. Следовательно конечное время работы алгоритма O(E logV)
### 4.9. Приближение решения задачи коммивояжера с помощью минимального остовного дерева.
Формулировка задачи коммивояжера:

Коммивояжер должен выйти из первого города, посетить по разу в неизвестном порядке города 2, 3, ..., n и вернуться в первый город. Расстояния между городами известны. В каком порядке следует обходить города, чтобы замкнутый путь (тур) коммивояжера был кратчайшим?

В терминах теории графов задачу можно сформулировать так: имеется полный ориентированный граф G = (V, E), каждой дуге (u, v) которого сопоставлен вес c(u, v). Требуется найти в этом графе гамильтонов контур наименьшей стоимости.

В наивной формулировке предполагаем, что для всех u, v, w ∈ V с(u, v)≤c(u, w)+c(w, v) ∈(неравенство треугольника), что нередко выполняется в практических задачах.

2 приближенный алгоритм для задачи коммивояжёра в метрическом пространстве:

Мы строим минимальное остовное дерево T исходного графа G. Продублируем каждое ребро дерева T и в полученном графе найдем эйлеров цикл. В пополненном рёбрами дереве мы можем найти эйлеров цикл (так как степени всех вершин уже стали чётными). Теперь просто удаляем из полученного цикла все повторения вершин и получаем ответ.

3/2 приближенный алгоритм для задачи коммивояжёра в метрическом пространстве:

Мы строим минимальное остовное дерево T исходного графа G. Выберем в T все вершины нечётной степени. На найденных вершинах нечётной степени построим минимальное полное паросочетание и добавим все полученные рёбра в дерево T. В пополненном рёбрами дереве мы можем найти эйлеров цикл (так как степени всех вершин уже стали чётными). Теперь просто удаляем из полученного цикла все повторения вершин и получаем ответ.

## 5. Потоки в сетях.
### 5.1. Определение сети. Определение потока. Физический смысл. Аналогия с законами Кирхгофа. Определение разреза. Понятия потока через разрез.
Сеть - G = (V,E) - ориентированный граф, в котором каждое ребро (u, v) имеет положительную пропускную способность c(u, v)>0. Выделяются 2 вершины: исток s и сток t

Поток f в G - действительная функция f: V x V -> R, удовлетворяющая условиям:
1) f(u, v) = -f(v, u) - антисимметричность
2) f(u, v) <= c(u, v) ограничение пропускной способности, если ребро ∉ сети G, f(u, v) = 0
3) SUM(v ∈ V)(f(u, v)) = 0 для всех вершин, кроме s, t - закон сохранения потока
   
* Когда пускаем поток по ребру, появляется обратное ребро с c(v, u)= 0 и f(v, u) = -f(u, v)
* Если f(v, u) == 0, ребро рисовать не нужно (т к в нем нет пользы)

Величина потока |f| = Sum(v ∈ V)f(s,v)

Физический смысл: количество жидкости, поступающей по трубам

Закон Кирхгофа: алгебраическая сумма токов ветвей, сходящихся в каждом узле любой цепи, равна нулю

Разрез <S,T> в сети G называется пара множеств S, T, удовлетворяющих следующим условиям:
1) исток лежит в S, сток лежит в T
2) S = V \ T

Пропускная способность разреза <S,T> обозначается c(S,T) и вычисляется по формуле: c(S,T)=sum(u∈S)sum(v∈T)c(u,v)

Поток в разрезе <S,T> обозначается f(S,T) и вычисляется по формуле f(S,T) = sum(u ∈S)sum(v ∈ T)f(u, v)
### 5.2. Определение разреза. Понятия потока через разрез. Доказательство факта, что поток через любой разрез одинаковый.
Разрез <S,T> в сети G называется пара множеств S, T, удовлетворяющих следующим условиям:
1) исток лежит в S, сток лежит в T
2) S = V \ T

Пропускная способность разреза <S,T> обозначается c(S,T) и вычисляется по формуле: c(S,T)=sum(u∈S)sum(v∈T)c(u,v)

Поток в разрезе <S,T> обозначается f(S,T) и вычисляется по формуле f(S,T) = sum(u ∈S)sum(v ∈ T)f(u, v)

Поток через любой разрез одинаковый:

Пусть <S,T> - разрез в G. Тогда f(S,T)=|f| (величина потока)

Док-во:
S = {s, v1,…,vk}
a) ({s},V\{s})-разрез->f({s},V\{s})=Sum(v∈V\{s})f(s, v)=|f| (по определению потока)
b) Пусть f({s, v1, .., vi}, V\{s, v1, .., vi}) - |f|. Тогда f({s, v1, .., vi+1}, V\{s, v1, .., vi+1}) = f({s, v1, .., vi}, V\{s, v1, .., vi}) - Sum(u ∈ {s, v1, .., vi})f(u, vi+1) + Sum(w ∉ {s, v1, .., vi}) f(vi+1, w)
### 5.3. Понятие остаточной сети. Понятие дополняющего пути. Необходимость отсутствия дополняющего пути для максимальности потока.
Остаточной пропускной способностью cf ребра (u, v) называется величина дополнительного потока, который можно направить из u в v, не превысив пропускную способность c(u, v).

cf(u, v) = c(u, v) - f(u, v)

Остаточная сеть, порожденная потоком f, является сеть Gf = (V, Ef), где Ef = {(u, v) ∈ E | cf(u, v) > 0}

Дополняющий путь p для G = (V, E) и потока f является простой путь из s в t в остаточной сети Gf = (V, Ef)

Необходимость отсутствия дополняющего пути для максимальности потока:
Очевидно, тут еще и достаточность)
### 5.4. Теорема Форда-Фалкерсона.
Следующие утверждения эквивалентны:
1)f - max поток
2)В Gf нет дополняющего пути из s в t
3)∃ <S,T> : f=c(S, T)
### 5.5. Алгоритм Форда-Фалкерсона. Поиск минимального разреза. Пример целочисленной сети, в котором алгоритм работает долго.
Алгоритм:

Пока есть хотя бы один путь в остаточной сети:
1)найти min cf на этом пути
2)протолкнуть такой поток вдоль этого пути
3)перестроить Gf
Dfs

Поиск минимального разреза. Штор-Вагнер
n - 1 раз повторять
1)Выбираем вершину u
2)Находим вершину v: w(u,v)-max
3)Объединяем вершины u v в одну
Берем 2 последние добавленные вершины s, t. Минимальным разрезом будет сумма ребер из t

Пример плохой
2 * 10^9
Асимптотика O( ans * (n + m)), ans - величина max потока
### 5.6. Алгоритм Эдмондса-Карпа. Доказательство, что кратчайшее расстояние в остаточной сети не уменьшается.
Алгоритм:

На каждой итерации алгоритма Форда - Фалкерсона находим кратчайший по числу ребер путь из s в t (bfs)

Лемма:

Пусть f и f’’ - два последовательных потока в алгоритме Эдмонс-Карпа. Пусть d(v) = dist(s,v) в Gf, d’(v) = dist(s, v) в Gf’ (dist считать как кол-во ребер чтобы дойти из s в v). Тогда: для любого v ∈ V d’ (v) >= d(v).

Док-во (от противного):

Пусть ∃ v-ы, для которых d’(v) < d(v). Выберем из них v: d’(v) - min. Нарисуем путь из s в v в Gf’. v ≠ s т к d(s) = d’(s) = 0. Значит, можно корректно определить предыдущую вершину на пути из s в v в Gf ‘. Пусть это u.

Тогда можем сказать, что d’(u) + 1 = d’(v) => d’(u) < d’(v) => d’(u) >= d(u) ( т к если бы d’(u) < d(u), а d’(u) < d’(v), то мы бы взяли вместо v u => расстояние d’(u) не могло уменьшиться)

Откуда ребро u, v в Gf ’?
1)u v было в Gf и осталось. Тогда d(v) <= d(u)+1 (т к d(v) > d(u) + 1 неверно). Поищем противоречие! d(v) <= d(u) + 1 <= d’(u) + 1 = d’(v) т е d(v) <= d’(v) !?
2) ребра u v не было в Gf ‘ => оно появилось => по (v, u) протолкнули поток, но т к мы знаем, что алгоритм всегда выбирает кратчайший путь, понимаем, что d(u) = d(v) + 1. Вспомним, что d(u) <= d’(u) = d’(v) - 1 => d’(v)-1 >= d(v) + 1 !?
### 5.7. Общая оценка времени работы алгоритма Эдмондса-Карпа. (не строго)
Асимптотика:

Итераций в алгоритме Эдмондса - Карпа будет O(V*E) (Каждое ребро пропадает O(V) раз т к dist(u) <= n, и dist всегда увеличивается (лемма) -> O(V*E) исчезновений. И дополняющих путей). 

Каждая итерация работает за O(E) т к просто bfs. Суммарно O(V*E^2)
### 5.8. Слоистая сеть. Алгоритм Диница. Оценка времени работы без доказательства.
Слоистая сеть:

Для начала определим для каждой вершины v данной сети G длину кратчайшего пути из истока и обозначим её d[v] (для этого можно воспользоваться dfs).

В слоистую сеть включаем только те рёбра (u,v) исходной сети, для которых d[u] + 1 = d[v]. Полученная сеть ациклична, и любой путь из s в t в слоистой сети является кратчайшим путём в исходной, из свойств обхода в ширину.

Блокирующий поток - это поток f в сети G, что в данной сети G не существует увеличивающего пути (при этом в сети Gf такой путь может существовать, то есть блокирующий поток не обязательно максимален).

Алгоритм Диница:

Пока не найден max поток <-> пока есть путь в остаточной сети
1)Построить слоистую сеть
2)Найти блокирующий поток
3)Добавить к f величину min capacity на блокирующем потоке (протолкнуть поток величиной min c -> остаточная сеть перестроится)

Асимптотика: O(V^2* E)

Алгоритм делает <= n итераций т к после каждой итерации dist’(s,t) > dist(s,t)

После пускания блокирующего потока пропадают ребра из i в i+1 слой, появляются обратные ребра из i+1 в i слой. Тогда любой путь из s в t должен пройти по всем уровням (т к нет ребра, которое перепрыгивает из i в i+k, k>1) => dist(s,t) только увеличивается => max итераций = n.

Поиск блокирующего пути занимает O(n*m) => Суммарное время O (n^2*m) что лучше чем Эдмондс Карп, работающий за O(n*m^2)

## RMQ. Sparse-table, дерево отрезков. LCA. Декартово дерево по неявному ключу.
### 6.1. RSQ и RMQ. Sparse-table.
Дерево отрезков — это структура данных, которая позволяет эффективно (т.е. за асимптотику O (log n) реализовать операции следующего вида: нахождение суммы/минимума элементов массива в заданном отрезке (a[l ... r], где l и r поступают на вход алгоритма), при этом дополнительно возможно изменение элементов массива: как изменение значения одного элемента, так и изменение элементов на целом подотрезке массива (т.е. разрешается присвоить всем элементам a[l ... r] какое-либо значение, либо прибавить ко всем элементам массива какое-либо число).

Для статических задач. (Не меняем массив)

Разреженная таблица - структура данных, позволяющая отвечать на запросы минимума на отрезке за O(1) с препроцессингом за O(nlog(n)) времени и памяти.

Ответ на запрос: min(l, r)

Разреженная таблица - это двумерный массив размера log n x n: t[k][i] = min{a_i, a_i+1, ... , a_i+2^k-1}, то есть считаем min на каждом отрезке длины 2^k.

Найдем k: 2**k <= (r-l)
min(l,r) = min(t[k][l],
t[k][j])
j: r-j = 2**k

RMQ - range min query - запрос минимума (максимума) на отрезке в массиве
RSQ - range sum query
### 6.2. Дерево отрезков. Обработка запросов от листьев. Обработка запросов от корня.
#### Реализация запроса в дереве отрезков сверху:
Пусть есть уже построенное дерево отрезков и идет запрос на полуинтервале [a...b). В качестве параметров рекурсий передаем следующие переменные: 
- node — номер (в массиве с деревом отрезков) текущей вершины дерева.
- a, b — левая и правая границы запрашиваемого полуинтервала.

Запустим рекурсивную процедуру от всего полуинтервала (вершины). Для текущего состояния проверяем следующие условия:
- Если текущий полуинтервал не пересекается с искомым, то возвращаем нейтральный элемент. Например: текущий [1...3), а искомый [3...5);
- Если текущий полуинтервал лежит внутри запрашиваемого полуинтервала, то возвращаем значение в текущей вершине. Например: текущий [2...3), а искомый [2...4);

Иначе переходим к рекурсивным вызовам функций от детей вершины. При этом возвращаем значение на текущем полуинтервале, как функцию (соответствующую типу нашего запроса) от результатов выполнения на детях.

Так как на каждом уровне дерева рекурсия может дойти до не более, чем двух
вершин, а всего уровней log n, то операция выполняется за O(log n).

int query(int node, int a, int b)
    l = tree[node].left
    r = tree[node].right
    if [l, r) ∩ [a, b) = ∅
        return ε// ε — нейтральный для данной операции элемент
    if [l, r) ⊂ [a, b)
        return tree[node].res
    return query(node * 2 + 1, a, b) ∘ query(node * 2 + 2, a, b)

#### Реализация запроса в дереве отрезков снизу:
int query(int left, int right) {
    leftRes = neutral;
    rightRes = neutral;
    while (left < right) {
        if (left % 2 = 0)
            leftRes = leftRes ∘ data[left];
        left = left / 2;
        if (right % 2 = 1)
            rightRes = data[right] ∘ rightRes;
        right = right / 2 — 1
    }
    if (left = right)
        leftRes = leftRes ∘ data[left];
    return leftRes ∘ rightRes;
}
### 6.3. Дерево отрезков. Изменение значения в массиве, обновление дерева отрезков. Множественные операции.
#### Реализация обновления в дереве отрезков:
void update (int v, int tl, int tr, int pos, int new_val) {
    if (tl = tr)
        t[v] = new_val;
    else {
        int tm = (tl + tr) / 2;
        if (pos < tm)
            update (v*2, tl, tm, pos, new_val);
        else
            update (v*2+1, tm+1, tr, pos, new_val);
        t[v] = t[v*2] + t[v*2+1];
    }
}
#### Реализация множественного обновления в дереве отрезков:
void update (int v, int tl, int tr, int l, int r, int add) {
    if (l > r)
        return;
    if (l = tl && tr = r)
        t[v] += add;
    else {
        int tm = (tl + tr) / 2;
        update (v*2, tl, tm, l, min(r,tm), add);
        update (v*2+1, tm+1, tr, max(l,tm+1), r, add);
    }
}
### 6.4. LCA. Метод двоичного подъёма.
Задача: для пары вершин u, v найти их минимального общего предка

Двоичный подъем:

Для каждой вершины посчитаем ее предка на расстоянии 2**k jump[v,k]. t = O(nlog(n)) Также посчитаем глубину каждой вершины

Ответ на запрос: lca(u,v)
1) поднимемся от более глубокой вершины u на уровень v, получим вершину u’
2) Прыгаем от каждой вершины на высоту 2**k, если попали в одну вершину, то пытаемся прыгнуть на 2**(k-1)
3) Если попали в разные, поднимаем u’, v на высоту 2**k, и повторяем 2)
4) Делать пока можно прыгнуть из u’, v t = O(log(n))

LCA == RMQ

Есть дерево, сделаем Эйлеров обход
Каждой вершине поставим в соответствие ее глубину
Утв: LCA на дереве соответствует RMQ на массиве
### 6.5. Декартово дерево по неявному ключу. Интерфейс быстрого массива: Доступ к элементу в позиции i, Вставка элемента в позицию i, Удаление элемента из позиции i, Конкатенация двух массивов, разделение массива на два.
Возьмём структуру данных динамический массив. Предположим, что нам необходима структура данных реализующая также операции: добавить элемент в любое место и удалить любой элемент. Такую структуру можно реализовать на базе декартового дерева, результат часто называют декартово дерево по неявному ключу (англ. Treap with implicit key).

Как известно, декартово дерево — это структура данных, объединяющая в себе бинарное дерево поиска и бинарную кучу. Оставим в нем только приоритет Y, а вместо ключа X будем использовать следующую величину: количество элементов в нашей структуре, находящихся левее нашего элемента (индекс элемента в массиве).

При этом сохранится структура двоичного дерева поиска по этому ключу (модифицированное декартово дерево так и останется декартовым деревом). Однако, с этим подходом появляется проблема: операции добавления и удаления элемента могут поменять нумерацию, и при наивной реализации на изменение всех ключей потребуется O(n) времени.

#### Вспомогательная величина С:
Основная идея решения: ключ X сам по себе нигде не хранится. Будем хранить вспомогательную величину C: количество вершин в поддереве нашей вершины (в поддерево включается и сама вершина). Все операции с обычным декартовым деревом делались сверху. Если по пути от корня до некой вершины просуммировать все такие величины в левых поддеревьях, в которые мы не пошли, увеличенные на единицу, то придя в саму вершину и добавив к этой величине количество элементов в её левом поддереве, мы получим как раз ее ключ X.

split(root,k) — разбиение дерева на два так, что в левом окажется ровно k вершин.

Пусть процедура split запущена в корне дерева с требованием отрезать от дерева k вершин. Также известно, что в левом поддереве вершины находится l вершин, а в правом r.

Рассмотрим все возможные случаи:
1) l>=k В этом случае нужно рекурсивно запустить процедуру split от левого ⩾ сына с тем же параметром k. При этом новым левым сыном корня станет правая часть ответа рекурсивной процедуры, а правой частью ответа станет корень.
2) l<k Случай симметричен предыдущему. Рекурсивно запустим процедуру split от правого сына с параметром k−l−1. При этом новым правым сыном корня станет левая часть ответа рекурсивной процедуры, а левой частью ответа станет корень.

(Treap, Treap) split(Treap t, int k)
    if t = ∅
        return (∅, ∅)
    int l = t.left.size
    if l ⩾ k
        (t1, t2) = split(t.left, k)
        t.left = t2
        update(t)
        return (t1, t)
    else
        (t1, t2) = split(t.right, k - l - 1)
        t.right = t1
        update(t)
    return (t, t2)

Т.к. в реализации merge для стандартного декартова дерева нет ни одного обращения к X, реализация merge для декартова дерева по неявному ключу идентична.

Treap merge(t1: Treap, t2: Treap):
    if t2 = ∅
        return t1
    if t1 = ∅
        return t2
    else if t1.y > t2.y
        t1.right = merge(t1.right, t2)
        return t1
    else
        t2.left = merge(t1, t2.left)
        return t2

Единственное действие, обеспечивающее корректность этих значений заключается в том, что после любого действия с детьми вершины нужно записать в ее поле C сумму этих значений в ее новых детях, увеличенную на единицу.

void update(Treap t)
    t.size = 1 + t.left.size + t.right.size
