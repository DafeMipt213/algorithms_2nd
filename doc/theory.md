# Теория по алгоритмам:

## 1. Обходы гррафа

### 1.1. Ориентированный граф, псевдограф. Неориентированный граф, псевдограф. Связность в неор. графе, компоненты связности. Слабая и сильная связность в ор. графе. Компоненты слабой, сильной связности.

#### Ориентированный граф.

1. `Ориентированным графом` (англ. directed graph) G называется пара G = (V,E), где V — множество вершин (англ. vertices), а E⊂V×V — множество рёбер.

2. Мультиорграф(`Псевдограф`) — это ориентированный граф, в котором разрешены кратные дуги, то есть дуги, имеющие те же начальные и конечные вершины. 
Мультиорграфом G называется упорядоченная пара G:=(V,A), в которой V — множество вершин, A — мультимножество упорядоченных пар вершин. Элементы этого множества называются дугами.

3. Ориентированный граф называется `слабо связным`, если соответствующий неориентированный граф является связным;
4. Ориентированный граф называется `сильно связным`, если всякая вершина v достижима из любой другой вершины v;
5. `Компонентой сильной связности` ориентированного графа называется максимальный по включению сильно связный подграф. Другими словами, это подграф, любые две вершины которого принадлежат какому-либо циклу, и содержащий все такие циклы для своих вершин.
6. `Компонентой слабой связности` ориентированного графа называют его максимальный слабо связный подграф.

#### Неориентированный граф.

1. `Неориентированным графом` (англ. undirected graph) G называется пара G = (V,E), где V — множество вершин, а E⊂{{v,u}:v,u ∈V} — множество рёбер.

2. Формально, мультиграфом(`псевдографом`) G называется упорядоченная пара G:=(V, E), в которой V — множество вершин, E — мультимножество неупорядоченных пар вершин. Элементы этого множества называются рёбрами.

3. Неориентированный граф называется `связным`, если все его вершины достижимы из некоторой вершины (эквивалентно, из любой его вершины).

4. `Компонентой связности` неориентированного графа называется максимальный по включению связный подграф.

### 1.2. Обход в глубину. Цвета вершин. Времена входа и выхода. Лемма о белых путях(с доказательством).

#### Обход в глубину.

```c++
vector < vector<int> > g; // граф
int n; // число вершин

vector<int> color; // цвет вершины (0, 1, или 2)

vector<int> time_in, time_out; // "времена" захода и выхода из вершины
int dfs_timer = 0; // "таймер" для определения времён

void dfs (int v) {
	time_in[v] = dfs_timer++;
	color[v] = 1;
	for (vector<int>::iterator i=g[v].begin(); i!=g[v].end(); ++i)
		if (color[*i] == 0)
			dfs (*i);
	color[v] = 2;
	time_out[v] = dfs_timer++;
}
```

####  Лемма о белых путях.

- Лемма: Не существует такого момента выполнения поиска в глубину, в который бы существовало ребро из черной вершины в белую.
- Доказательство: Пусть в процессе выполнения процедуры dfs нашлось ребро из черной вершины v в белую вершину u. Рассмотрим момент времени, когда мы запустили dfs(v). В этот момент вершина v была перекрашена из белого в серый, а вершина u была белая. Далее в ходе выполнения алгоритма будет запущен dfs(u), поскольку обход в глубину обязан посетить все белые вершины, в которые есть ребро из v. По алгоритму вершина v будет покрашена в черный цвет тогда, когда завершится обход всех вершин, достижимых из нее по одному ребру, кроме тех, что были рассмотрены раньше нее. Таким образом, вершина v может стать черной только тогда, когда dfs выйдет из вершины u, и она будет покрашена в черный цвет. Получаем противоречие.


### 1.3. Проверка связности неориентированного графа. Поиск цикла в неориентированном и ориентированном графе. Топологическая сортировка.

#### Проверка связности неориентированного графа.

Небольшая модификация алгоритма обхода в глубину, в которой будем возвращать количество посещенных вершин. Запустим такой dfs() от некоторой вершины графа G, если его результат равен |V|, то мы побывали во всех вершинах графа, а следовательно он связен, иначе какие-то вершины остались непосещенными. Работает алгоритм за O(|V|+|E|).

```c++
// visited — массив цветов вершин  
int dfs(u: int, visited: bool[]):              
    int visitedVertices = 1
    visited[u] = true                           // помечаем вершину как пройденную
    for v: uv ∈ E                               // проходим по смежным с u вершинам
        if not visited[v]                       // проверяем, не находились ли мы ранее в выбранной вершине
            visitedVertices += dfs(v, visited)
    return visitedVertices
```


#### Поиск цикла в неориентированном и ориентированном графе.

Пусть дан ориентированный или неориентированный граф без петель и кратных рёбер. Требуется проверить, является ли он ациклическим, а если не является, то найти любой цикл.

Произведём серию поисков в глубину в графе. Т.е. из каждой вершины, в которую мы ещё ни разу не приходили, запустим поиск в глубину, который при входе в вершину будет красить её в серый цвет, а при выходе - в чёрный. И если поиск в глубину пытается пойти в серую вершину, то это означает, что мы нашли цикл (если граф неориентированный, то случаи, когда поиск в глубину из какой-то вершины пытается пойти в предка, не считаются).

```c++
int n;
vector < vector<int> > g;
vector<char> cl;
vector<int> p;
int cycle_st, cycle_end;

bool dfs (int v) {
	cl[v] = 1;
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
		if (cl[to] == 0) {
			p[to] = v;
			if (dfs (to))  return true;
		}
		else if (cl[to] == 1) {
			cycle_end = v;
			cycle_st = to;
			return true;
		}
	}
	cl[v] = 2;
	return false;
}

int main() {
	... чтение графа ...

	p.assign (n, -1);
	cl.assign (n, 0);
	cycle_st = -1;
	for (int i=0; i<n; ++i)
		if (dfs (i))
			break;

	if (cycle_st == -1)
		puts ("Acyclic");
	else {
		puts ("Cyclic");
		vector<int> cycle;
		cycle.push_back (cycle_st);
		for (int v=cycle_end; v!=cycle_st; v=p[v])
			cycle.push_back (v);
		cycle.push_back (cycle_st);
		reverse (cycle.begin(), cycle.end());
		for (size_t i=0; i<cycle.size(); ++i)
			printf ("%d ", cycle[i]+1);
	}
}
```

#### Топологическая сортировка.
Дан ориентированный граф с n вершинами и m рёбрами. Требуется перенумеровать его вершины таким образом, чтобы каждое рёбро вело из вершины с меньшим номером в вершину с большим. Иными словами, требуется найти перестановку вершин (топологический порядок), соответствующую порядку, задаваемому всеми рёбрами графа.
(Топологическая сортировка — упорядочивание вершин ациклического ориентированного графа согласно частичному порядку, заданному ребрами орграфа на множестве его вершин.)
Топологическая сортировка может быть не единственной (например, если граф — пустой; или если есть три такие вершины a, b, c, что из a есть пути в b и в c, но ни из b в c, ни из c в b добраться нельзя).

Топологической сортировки может не существовать вовсе — если граф содержит циклы (поскольку при этом возникает противоречие: есть путь и из одной вершины в другую, и наоборот).
```c++
int n; // число вершин
vector<int> g[MAXN]; // граф
bool used[MAXN];
vector<int> ans;
 
void dfs (int v) {
	used[v] = true;
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
		if (!used[to])
			dfs (to);
	}
	ans.push_back (v);
}
 
void topological_sort() {
	for (int i=0; i<n; ++i)
		used[i] = false;
	ans.clear();
	for (int i=0; i<n; ++i)
		if (!used[i])
			dfs (i);
	reverse (ans.begin(), ans.end());
}
```

### 1.4. Нахождение компонент сильной связности. Алгоритм Косарайю с доказательством корректности(концепция). Алгоритм Тарьяна без доказательства корректности.

#### Нахождение компонент сильной связности.

Дан ориентированный граф G, множество вершин которого V и множество рёбер — E. Петли и кратные рёбра допускаются. Обозначим через n количество вершин графа, через m — количество рёбер.

Напомним, что `компонентой сильной связности` (strongly connected component) называется такое (максимальное по включению) подмножество вершин C, что любые две вершины этого подмножества достижимы друг из друга, т.е. для любых u,v из C: u -> v, v -> u, где символом -> здесь и далее мы будем обозначать достижимость, т.е. существование пути из первой вершины во вторую. Понятно, что компоненты сильной связности для данного графа не пересекаются, т.е. фактически это разбиение всех вершин графа. Отсюда логично определение конденсации G как графа, получаемого из данного графа сжатием каждой компоненты сильной связности в одну вершину. Каждой вершине графа конденсации соответствует компонента сильной связности графа G, а ориентированное ребро между двумя вершинами $C_i$ и $C_j$ графа конденсации проводится, если найдётся пара вершин u из $C_i$, из $C_j$, между которыми существовало ребро в исходном графе, т.е. (u,v) из E.

Важнейшим свойством графа конденсации является то, что он ацикличен. Действительно, предположим, что C -> C', докажем, что C' !-> C. Из определения конденсации получаем, что найдутся две вершины u из C и v из C', что u -> v. Доказывать будем от противного, т.е. предположим, что C' -> C, тогда найдутся две вершины u' из C и v' из C', что v' -> u'. Но т.к. u и u' находятся в одной компоненте сильной связности, то между ними есть путь; аналогично для v и v'. В итоге, объединяя пути, получаем, что v -> u, и одновременно u -> v. Следовательно, u и v должны принадлежать одной компоненте сильной связности, т.е. получили противоречие, что и требовалось доказать.

#### Алгоритм Косарайю с доказательством корректности(концепция).

- Алгоритм Косарайю предназначен для поиска компонент сильной связности в ориентированном графе и состоит из трёх шагов:

    1. Выполнить поиск в глубину (DFS), пока не будут «помечены» все вершины. Вершина считается «помеченной», когда ей присвоено время выхода из рекурсии (см. основные понятия).

    2. Инвертировать исходный граф

    3. Выполнить DFS в порядке убывания пометок вершин.

Полученные деревья каждого такта DFS последнего шага являются компонентами сильной связности

- Доказательство корректности алгоритма. Немного уточним, что требуется доказать: Вершины u и v сильно связаны ⇔ после выполнения алгоритма они принадлежат одному дереву такта DFS.

        Если вершины u и v были сильно связаны в графе G, на третьем этапе будет найден путь из одной вершины в другую (по Лемме (Инвертирование рёбер цикла не влияет на его цикличность)), так как на первом шаге был найден путь u→v, а на третьем -- путь v→u. Это означает, что по окончании алгоритма обе вершины лежат в одном дереве.

    Вершины u и v лежат в одном и том же дереве поиска в глубину на третьем шаге алгоритма. Значит, они обе достижимы из корня r этого дерева.

    Вершина r была рассмотрена на 3 шаге раньше всех, значит время выхода из неё на 1 шаге больше, чем время выхода из вершин u и v. Из этого мы получаем 2 случая:

    Обе эти вершины были достижимы из r в исходном графе. Это означает сильную связность вершин u и r и сильную связность вершин v и r (по Лемме 3). Склеивая пути мы получаем связность вершин u и v (по Лемме 1)

    Хотя бы одна вершина не достижима из r в исходном графе, например v. Значит и r была не достижима из v в исходном графе, так как время выхода из r — больше (если бы она была достижима, то время выхода из v было бы больше, чем из r, просмотрите ещё раз первый шаг примера). Значит между этими вершинами нет пути (ни в исходном, ни в инвертированном графах), но последнего быть не может, потому что по условию v достижима из r на 3 шаге (в инвертированном графе)

    Значит, из случая 1 и не существования случая 2 получаем, что вершины u и v сильно связаны в обоих графах


#### Алгоритм Тарьяна без доказательства корректности.
Основой для алгоритма является структура данных "Система непересекающихся множеств", которая и была изобретена Тарьяном (Tarjan).

Алгоритм фактически представляет собой обход в глубину из корня дерева, в процессе которого постепенно находятся ответы на запросы. А именно, ответ на запрос (v,u) находится, когда обход в глубину находится в вершине u, а вершина v уже была посещена, или наоборот.

Итак, пусть обход в глубину находится в вершине v (и уже были выполнены переходы в её сыновей), и оказалось, что для какого-то запроса (v,u) вершина u уже была посещена обходом в глубину. Научимся тогда находить **LCA** этих двух вершин.

Заметим, что **LCA**(v,u) является либо самой вершиной v, либо одним из её предков. Получается, нам надо найти самую нижнюю вершину среди предков v (включая её саму), для которой вершина u является потомком. Заметим, что при фиксированном v по такому признаку (т.е. какой наименьший предок v является и предком какой-то вершины) вершины дерева дерева распадаются на совокупность непересекающихся классов. Для каждого предка p != v вершины v её класс содержит саму эту вершину, а также все поддеревья с корнями в тех её сыновьях, которые лежат "слева" от пути до v (т.е. которые были обработаны ранее, чем была достигнута v).

Нам надо научиться эффективно поддерживать все эти классы, для чего мы и применим структуру данных "Система непересекающихся множеств". Каждому классу будет соответствовать в этой структуре множество, причём для представителя этого множества мы определим величину **ANCESTOR** — ту вершину p, которая и образует этот класс.

Рассмотрим подробно реализацию обхода в глубину. Пусть мы стоим в некоторой вершине v. Поместим её в отдельный класс в структуре непересекающихся множеств, **ANCESTOR**[v] = v. Как обычно в обходе в глубину, перебираем все исходящие рёбра (v, to). Для каждого такого to мы сначала должны вызвать обход в глубину из этой вершины, а потом добавить эту вершину со всем её поддеревом в класс вершины v. Это реализуется операцией **Union** структуры данных "система непересекающихся множеств", с последующей установкой **ANCESTOR** = v для представителя множества (т.к. после объединения представитель класса мог измениться). Наконец, после обработки всех рёбер мы перебираем все запросы вида (v,u), и если u была помечена как посещённая обходом в глубину, то ответом на этот запрос будет вершина **LCA**(v,u) = **ANCESTOR**[FindSet(u)]. Нетрудно заметить, что для каждого запроса это условие (что одна вершина запроса является текущей, а другая была посещена ранее) выполнится ровно один раз.

Оценим асимптотику. Она складывается из нескольких частей. Во-первых, это асимптотика обхода в глубину, которая в данном случае составляет O(n). Во-вторых, это операции по объединению множеств, которые в сумме для всех разумных n затрачивают O(n) операций. В-третьих, это для каждого запроса проверка условия (два раза на запрос) и определение результата (один раз на запрос), каждое, опять же, для всех разумных n выполняется за O(1). Итоговая асимптотика получается O(n+m), что означает для достаточно больших m (n = O(m)) ответ за O(1) на один запрос.


### 1.5. Компоненты реберной двусвязности. Мосты. Поиск мостов.

#### Компоненты реберной двусвязности.

`Компонентами рёберной двусвязности` (англ. costal doubly-linked components) графа называют его подграфы, множества вершин которых - классы эквивалентности рёберной двусвязности, а множества рёбер - множества ребер из соответствующих классов эквивалентности.


#### Мосты.

`Мостом` называется такое ребро, удаление которого делает граф несвязным (или, точнее, увеличивает число компонент связности). 

#### Поиск мостов.

- Алгоритм: 
    Запустим обход в глубину из произвольной вершины графа; обозначим её через **root**. Заметим следующий факт (который несложно доказать):

    Пусть мы находимся в обходе в глубину, просматривая сейчас все рёбра из вершины v. Тогда, если текущее ребро (v,to) таково, что из вершины to и из любого её потомка в дереве обхода в глубину нет обратного ребра в вершину v или какого-либо её предка, то это ребро является мостом. В противном случае оно мостом не является. (В самом деле, мы этим условием проверяем, нет ли другого пути из v в to, кроме как спуск по ребру (v,to) дерева обхода в глубину.)
    Теперь осталось научиться проверять этот факт для каждой вершины эффективно. Для этого воспользуемся "временами входа в вершину", вычисляемыми алгоритмом поиска в глубину.

    Итак, пусть tin[v] — это время захода поиска в глубину в вершину v. Теперь введём массив fup[v], который и позволит нам отвечать на вышеописанные запросы. Время fup[v] равно минимуму из времени захода в саму вершину tin[v], времён захода в каждую вершину p, являющуюся концом некоторого обратного ребра (v,p), а также из всех значений fup[to] для каждой вершины to, являющейся непосредственным сыном v в дереве поиска:

    fup[v] = min{ tin[v], tin[p], fup(to)} (v, p) - back edge, (v, to) - tree edge (здесь "back edge" — обратное ребро, "tree edge" — ребро дерева)

    Тогда, из вершины v или её потомка есть обратное ребро в её предка тогда и только тогда, когда найдётся такой сын to, что fup[to] <= tin[v]. (Если fup[to] = tin[v], то это означает, что найдётся обратное ребро, приходящее точно в v; если же fup[to] < tin[v], то это означает наличие обратного ребра в какого-либо предка вершины v.)

    Таким образом, если для текущего ребра (v,to) (принадлежащего дереву поиска) выполняется fup[to] > tin[v], то это ребро является мостом; в противном случае оно мостом не является.


### 1.6. Компоненты вершинной двусвязности. Точки сочленения. Поиск точек сочленения.

#### Компоненты вершинной двусвязности.

`Компонентами вершинной двусвязности` графа, называют его подграфы, множества ребер которых — классы эквивалентности вершинной двусвязности, а множества вершин — множества всевозможных концов ребер из соответствующих классов.

#### Точки сочленения.

`Точкой сочленения` называется вершина, при удалении которой связный неориентированный граф становится несвязным.

#### Поиск точек сочленения.

- Алгоритм: 
    Запустим обход в глубину из произвольной вершины графа; обозначим её через **root**. Заметим следующий факт (который несложно доказать):

    Пусть мы находимся в обходе в глубину, просматривая сейчас все рёбра из вершины v != **root**. Тогда, если текущее ребро (v,to) таково, что из вершины to и из любого её потомка в дереве обхода в глубину нет обратного ребра в какого-либо предка вершины v, то вершина v является точкой сочленения. В противном случае, т.е. если обход в глубину просмотрел все рёбра из вершины v, и не нашёл удовлетворяющего вышеописанным условиям ребра, то вершина v не является точкой сочленения. (В самом деле, мы этим условием проверяем, нет ли другого пути из v в to)
    Рассмотрим теперь оставшийся случай: v = **root**. Тогда эта вершина является точкой сочленения тогда и только тогда, когда эта вершина имеет более одного сына в дереве обхода в глубину. (В самом деле, это означает, что, пройдя из **root** по произвольному ребру, мы не смогли обойти весь граф, откуда сразу следует, что **root** — точка сочленения).
    (Ср. формулировку этого критерия с формулировкой критерия для алгоритма поиска мостов.)

    Теперь осталось научиться проверять этот факт для каждой вершины эффективно. Для этого воспользуемся "временами входа в вершину", вычисляемыми алгоритмом поиска в глубину.

    Итак, пусть tin[v] — это время захода поиска в глубину в вершину v. Теперь введём массив fup[v], который и позволит нам отвечать на вышеописанные запросы. Время fup[v] равно минимуму из времени захода в саму вершину tin[v], времён захода в каждую вершину p, являющуюся концом некоторого обратного ребра (v,p), а также из всех значений fup[to] для каждой вершины to, являющейся непосредственным сыном v в дереве поиска:

    fup[v] = min{tin[v], tin[p], fup(to)} (v, p) - back edge, (v, to) - tree edge (здесь "back edge" — обратное ребро, "tree edge" — ребро дерева)

    Тогда, из вершины v или её потомка есть обратное ребро в её предка тогда и только тогда, когда найдётся такой сын to, что fup[to] < tin[v].

    Таким образом, если для текущего ребра (v,to) (принадлежащего дереву поиска) выполняется fup[to] >= tin[v], то вершина v является точкой сочленения. Для начальной вершины v = **root** критерий другой: для этой вершины надо посчитать число непосредственных сыновей в дереве обхода в глубину.


### 1.7. Волновой алгоритм. Обход в ширину (применение очереди в волновом алгоритме).

#### Волновой алгоритм.

Алгоритм волновой трассировки (волновой алгоритм) — алгоритм поиска пути, алгоритм поиска кратчайшего пути на планарном графе. Принадлежит к алгоритмам, основанным на методах поиска в ширину.

Алгоритм предназначен для поиска кратчайшего пути от стартовой ячейки к конечной ячейке, если это возможно, либо, при отсутствии пути, выдать сообщение о непроходимости[6].

Работа алгоритма включает в себя три этапа: инициализацию, распространение волны и восстановление пути.

Инициализация
```c
Пометить стартовую ячейку 
d := 0 
```
Распространение волны
```c
ЦИКЛ
  ДЛЯ каждой ячейки loc, помеченной числом d
    пометить все соседние свободные непомеченные ячейки числом d + 1
  КЦ
  d := d + 1
ПОКА (финишная ячейка не помечена) И (есть возможность распространения волны) 
```
Восстановление пути

```c
ЕСЛИ финишная ячейка помечена
ТО
  перейти в финишную ячейку
  ЦИКЛ
    выбрать среди соседних ячейку, помеченную числом на 1 меньше числа в текущей ячейке
    перейти в выбранную ячейку и добавить её к пути
  ПОКА текущая ячейка — не стартовая
  ВОЗВРАТ путь найден
ИНАЧЕ
  ВОЗВРАТ путь не найден
```

#### Обход в ширину (применение очереди в волновом алгоритме).

- Поиск в ширину (англ. breadth-first search) — один из основных алгоритмов на графах, позволяющий находить все кратчайшие пути от заданной вершины и решать многие другие задачи.

- Описание алгоритма
    На вход алгоритма подаётся невзвешенный граф и номер стартовой вершины s. Граф может быть как ориентированным, так и неориентированным — для алгоритма это не важно.

    Основную идею алгоритма можно понимать как процесс «поджигания» графа: на нулевом шаге мы поджигаем вершину s, а на каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей, в конечном счете поджигая весь граф.

    Если моделировать этот процесс, то за каждую итерацию алгоритма будет происходить расширение «кольца огня» в ширину на единицу. Номер шага, на котором вершина v начинает гореть, в точности равен длине её минимального пути из вершины s.

```c++
vector<int> g[maxn];

void bfs(int s) {
    queue<int> q;
    q.push(s);
    
    vector<int> d(n, -1), p(n);
    d[s] = 0;
    
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (int u : g[v]) {
            if (d[u] == -1) {
                q.push(u);
                d[u] = d[v] + 1;
                p[u] = v;
            }
        }
    }
} 
```

Теперь, чтобы восстановить кратчайший путь до какой-то вершины v, это можно сделать через массив p:
```c++
while (v != s) {
    cout << v << endl;
    v = p[v];
}
```
Обратим внимание, что путь выведется в обратном порядке.


### 1.8. Критерий существования Эйлерова пути и цикла в ориентированном и неориентированном графе. Поиск эйлерова пути и цикла.

##### Критерий существования Эйлерова пути и цикла в неориентированном графе.

- Согласно теореме, доказанной Эйлером, эйлеров цикл существует тогда и только тогда, когда 
    1. Граф связный или будет являться связным, если удалить из него все изолированные вершины.
    2. В нём отсутствуют вершины нечётной степени.

- Эйлеров путь в графе существует тогда и только тогда, когда 
    1. Граф связный
    2. Содержит не более двух вершин нечётной степени. Ввиду леммы о рукопожатиях, число вершин с нечётной степенью должно быть чётным. А значит эйлеров путь существует только тогда, когда это число равно нулю или двум. Причём, когда оно равно нулю, эйлеров путь вырождается в эйлеров цикл.

##### Критерий существования Эйлерова пути и цикла в ориентированном графе.
- В ориентированном графе G=(V,E) существует эйлеров цикл тогда и только тогда, когда:
    1. Входная степень любой вершины равна ее выходной степени.
    2. Все компоненты слабой связности кроме, может быть одной, не содержат ребер.
- В ориентированном графе G=(V,E) существует эйлеров путь если:
    1. Входная степень любой вершины равна ее выходной степени, кроме двух вершин графа, для одной из которых (deg+) − (deg−) = 1, а для другой (deg+) − (deg−) = −1 .
    2. Все компоненты слабой связности кроме, может быть одной, не содержат ребер.

#### Поиск эйлерова пути и цикла.

- Поиск эйлерова пути в графе
    Можно всегда свести задачу поиска эйлерова пути к задаче поиска эйлерова цикла. Действительно, предположим, что эйлерова цикла не существует, а эйлеров путь существует. Тогда в графе будет ровно 2 вершины нечётной степени. Соединим эти вершины ребром, и получим граф, в котором все вершины чётной степени, и эйлеров цикл в нём существует. Найдём в этом графе эйлеров цикл (алгоритмом, описанным ниже), а затем удалим из ответа несуществующее ребро.

- Поиск эйлерова цикла в графе
    Будем рассматривать самый общий случай — случай ориентированного мультиграфа, возможно, с петлями. Также мы предполагаем, что эйлеров цикл в графе существует (и состоит хотя бы из одной вершины). Для поиска эйлерова цикла воспользуемся тем, что эйлеров цикл — это объединение всех простых циклов графа. Следовательно, наша задача — эффективно найти все циклы и эффективно объединить их в один.

    Реализовать это можно, например, так, рекурсивно:
    ```c
    procedure find_all_cycles (v)
    var массив cycles
    1. пока есть цикл, проходящий через v, находим его
        добавляем все вершины найденного цикла в массив cycles (сохраняя порядок обхода)
        удаляем цикл из графа
    2. идем по элементам массива cycles
        каждый элемент cycles[i] добавляем к ответу
        из каждого элемента рекурсивно вызываем себя: find_all_cycles (cycles[i])
    ```
    Достаточно вызвать эту процедуру из любой вершины графа, и она найдёт все циклы в графе, удалит их из графа и объединит их в один эйлеров цикл.
    Для поиска цикла на шаге 1 используем поиск в глубину.
    Сложность полученного алгоритма — O(|E|), то есть линейная относительно количества рёбер в данном графе.

## 2. Планарность графа

### 2.1. Формула Эйлера. Теорема Портнягина-Куратовского. Теорема Вагнера

#### Формула Эйлера.
Для произвольного плоского связного графа G с V вершинами, E ребрами и F гранями справедливо следующее соотношение: `V − E + F = 2`.

#### Теорема Портнягина-Куратовского
Теорема Понтрягина — Куратовского, или теорема Куратовского, — теорема в теории графов, дающая необходимое и достаточное условие планарности графа. Имеет эквивалентную формулировку на языке миноров, так называемою теорему Вагнера.

Теорема утверждает, что графы $K_5$ (полный граф на 5 вершинах) и $K_{3,3}$ (полный двудольный граф имеющий по 3 вершины в каждой доле) являются единственными минимальными непланарными графами.

#### Теорема Вагнера.

Теорема Вагнера — характеризация планарных графов тесно связанная с теоремой Понтрягина — Куратовского.

Теорема утверждает, что конечный граф является планарным тогда и только тогда, когда его миноры не включают ни $K_5$ (полный граф с пятью вершинами), ни $K_{3,3}$ (коммунальный граф, полный двудольный граф с тремя вершинами в каждой доле).

### 2.2. Гамма алгоритм. Контактная вершина.

#### Гамма алгоритм
- Чтобы проверить планарность графа и произвести его плоскую укладку, удобно пользоваться гамма-алгоритмом.
- Определения:
    1. Сегмент графа Г относительно подграфа H — компонента связности графа G\H.
    2. Допустимая грань сегмента — грань графа H, содержащая все контактные вершины.
    3. `Контактная вершина` сегмента S графа Г подграфа H — любая вершина в S и в H.
    4. Гамма-цепь сегмента — любая цепь без повторов вершин, содержащих ровно две контактные вершины — начало и конец.
- Алгоритм:
    1. Уложить на плоскость любой цикл H графа G без повторов вершин.
    2. Построить все сегменты S_1,..,S_k графа G по H.
    3. Если есть сегмент S_i c одной допустимой гранью — выбрать его.
    4. Если все сегменты имеют несколько дополнительных граней — выбрать любой.
    5. Выбрать произвольную гамма-цепь сегмента и уложить её в допустимую грань.
    6. Перейти к шагу (2), добавив гамма-цепь к графу H.

### 2.3. Теорема о корректности Гамма алгоритма. Асимптотика алгоритма.

#### Теорема о корректности Гамма алгоритма.
- Теорема: Гамма-алгоритм корректен, то есть если G — планарный граф, то результатом каждого шага гамма-алгоритма является частичная укладка G'.
- Доказательство:
    Докажем индукцией по числу шагов.

    База индукции: полученный на этапе инициализации граф G_0 является простым циклом, он будет присутствовать в любой укладке графа G. Таким образом, G_0  является частичной укладкой.

    Шаг индукции: пусть граф G_{k−1}, полученный на k−1-м шаге работы алгоритма, является частичной укладкой. Докажем, что граф G_k=G_{k−1} ∪ L_k, полученный на k-м шаге присоединением цепи L_k, также является частичной укладкой.

    Заметим, что на текущем шаге нет такого сегмента S  относительно G_{k−1}, для которого бы выполнялось равенство Γ(S)=∅, так как в противном случае существовала бы цепь этого сегмента, контактные вершины которой принадлежали бы разным граням и укладка которой была бы невозможна. Следовательно, нельзя было бы уложить S,что противоречит тому, что G — планарный граф. Значит, мы можем рассматривать только следующие два случая:
    1. Существует сегмент S для которого есть единственная вмещающая грань Γ, то есть |Γ(S)|=1. Так как только грани Γ принадлежат все контактные вершины S, то укладка этого сегмента в эту грань неизбежна. Это значит, что помещая любую цепь L⊂S, снова получим частичную укладку графа.
    
    2. Для любого сегмента S |Γ(S)|⩾2. Построим граф A(G′k−1), который по лемме 2 является двудольным. Рассмотрим его связную компоненту K, которая содержит не менее двух вершин. Граф K также является двудольным. По лемме 1 для любого сегмента S∈K справедливо Γ(S)={Γ1,Γ2}. Так как граф K двудольный, то мы можем по очереди помещать сегменты K в разные грани, причем конфликтующих сегментов не возникнет в силу четности всех циклов в графе. Результатом будет частичная укладка графа.

    Таким образом, на каждом шаге мы получаем частичную укладку графа, что доказывает корректность гамма-алгоритма.

#### Асимптотика алгоритма - O(n^3).

## 3. Кратчайшие пути во взвешенном графе.

### 3.1. Алгоритм Дейкстры. Доказательство корректности(с доказательством). Оценка времени работы. Дерево кратчайших путей.

#### Алгоритм Дейкстры.
Алгоритм Дейкстры (англ. Dijkstra’s algorithm) — алгоритм на графах, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. Находит кратчайшие пути от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса.

```c
func dijkstra(s):
    for v∈V
        d[v] = ∞
        used[v] = false
    d[s] = 0
    for i∈V
        v = null
        for j∈V    // найдём вершину с минимальным расстоянием
            if !used[j] and (v == null or d[j] < d[v])
                v = j
        if d[v] == ∞
            break
        used[v] = true
        for e : исходящие из v рёбра     // произведём релаксацию по всем рёбрам, исходящим из v
            if d[v] + e.len < d[e.to]
                d[e.to] = d[v] + e.len
```

#### Доказательство корректности(с доказательством)
- Пусть G=(V,E) — ориентированный взвешенный граф, вес рёбер которого неотрицателен, s — стартовая вершина. Тогда после выполнения алгоритма Дейкстры d(u)=ρ(s,u)
 для всех u, где ρ(s,u) — длина кратчайшего пути из вершины s в вершину u.

Докажем по индукции, что в момент посещения любой вершины u, d(u)=ρ(s,u).

На первом шаге выбирается s, для неё выполнено: d(s)=ρ(s,s)=0. Пусть для n первых шагов алгоритм сработал верно и на n+1 шагу выбрана вершина u. Докажем, что в этот момент d(u)=ρ(s,u). Для начала отметим, что для любой вершины v, всегда выполняется d(v)⩾ρ(s,v) (алгоритм не может найти путь короче, чем кратчайший из всех существующих). Пусть P — кратчайший путь из s в u, v — первая непосещённая вершина на P, z — предшествующая ей (следовательно, посещённая). Поскольку путь P кратчайший, его часть, ведущая из s через z в v, тоже кратчайшая, следовательно ρ(s,v)=ρ(s,z)+w(zv). По предположению индукции, в момент посещения вершины z выполнялось d(z)=ρ(s,z), следовательно, вершина v
тогда получила метку не больше чем d(z)+w(zv)=ρ(s,z)+w(zv)=ρ(s,v), следовательно, d(v)=ρ(s,v). С другой стороны, поскольку сейчас мы выбрали вершину u, её метка минимальна среди непосещённых, то есть d(u)⩽d(v)=ρ(s,v)⩽ρ(s,u), где второе неравенсто верно из-за ранее упомянутого определения вершины v в качестве первой непосещённой вершины на P, то есть вес пути до промежуточной вершины не превосходит веса пути до конечной вершины вследствие неотрицательности весовой функции. Комбинируя это с d(u)⩾ρ(s,u), имеем d(u)=ρ(s,u), что и требовалось доказать. Поскольку алгоритм заканчивает работу, когда все вершины посещены, в этот момент d(u)=ρ(s,u) для всех u.

#### Оценка времени работы.
- Если $m = n ^ 2$(граф плотный), то $O(n^2)$.
- Если $m = n$(граф разреженный), то $O(m log n)$.

#### Дерево кратчайших путей.
Решение ряда прикладных задач сводится к нахождению дерева кратчайших путей с корнем в заданной вершине s. Такое дерево дает кратчайшие (s, у)-пути от заданной вершины 5 до любой вершины v е V орграфа G - (V, Е). Если веса всех дуг орграфа G неотрицательны, то дерево кратчайших путей можно построить с помощью алгоритма Дейкстры.

### 3.2. Потенциалы. Условие применимости алгоритма Дейкстры для измененных длин ребер. Потенциал π(v) = ρ(v, t).) = ρ(v) = ρ(v, t)., t).

### 3.3. Алгоритм A*. Условие монотонности на эвристику. Примеры эвристик.

#### Алгоритм A*


### 3.4. Алгоритм Форда-Беллмана. Хранение в матрице: Dv) = ρ(v, t).k равно длине кратчайшего пути до вершины v) = ρ(v, t). за ровно k ребер (не более k ребер). Доказательство корректности(полное). Оценка времени работы.
### 3.5. Восстановление пути. Детектирование цикла отрицательного веса. Поиск самого цикла.
### 3.6. Нахождение кратчайших путей с учетом циклов отрицательного веса.
### 3.7. Алгоритм Флойда. Доказательство (концепция). Восстановление пути.
### 3.8. Нахождение цикла отрицательного веса.
### 3.9. Алгоритм Джонсона. Добавление фиктивного корня и фиктивных ребер для запуска алгоритма Форда-Беллмана.
